////	UIView.as//	Core UI Framework////	Created by Jesper Svensson on 2011-07//	Copyright 2011 Jesper Svensson. All rights reserved.//package se.raweden.ui.view{		import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Rectangle;		import se.raweden.core.core;
			// events metadata for DragEvent	[Event(name="dragComplete", type="se.raweden.ui.events.UIDragEvent")]	[Event(name="dragDrop", type="se.raweden.ui.events.UIDragEvent")]	[Event(name="dragEnter", type="se.raweden.ui.events.UIDragEvent")]	[Event(name="dragExit", type="se.raweden.ui.events.UIDragEvent")]	[Event(name="dragStart", type="se.raweden.ui.events.UIDragEvent")]		/**	 * The UIView class defines a rectangular area on the sceen and the interface for managing the content in that area.	 * More sophisticated content can be presented by subclassing UIView and implementing the necessary drawing 	 * and event-handling code yourself. The Core UI framework also includes a set of standard subclasses you can use.	 * 	 * @author Raweden.	 */	public class UIView extends Sprite{		use namespace core;				/** 		 * Constant that indicates to the <code>render()</code> method that the layout have been invalidated.		 */		public static const INVALIDATE_LAYOUT:String = "layout";		/** 		 * Constant that indicates to the <code>render()</code> method that the size have been invalidated.		 */		public static const INVALIDATE_DISPLAY:String = "display";				// instance core variables.		core var m_window:UIWindow;		core var m_autoresize:Boolean = false;		core var m_bounds:Rectangle;		core var m_width:Number;		core var m_height:Number;		// instance private variables.				private var m_invalidates:Object;		private var m_invalidated:Boolean = false;		private var m_tag:int;		// visual appearance.		private var m_backgroundColor:int = -1;		private var m_backgroundAlpha:Number = 1;				/**		 * 		 */		public function UIView(parent:DisplayObjectContainer = null,frame:Rectangle = null){			super();			// initilize the view.			init();			// if the parant is specilazed the component is added to that container.			if(parent){				parent.addChild(this);			}			// if the bounds where specified. the bounds is set for the UIView.			if(frame){				moveTo(frame.x,frame.y);				resize(frame.width,frame.height);			}		}		// initlizes the UIView instance.		private function init():void{			m_bounds = new Rectangle();			m_invalidates = new Object();		}				//------------------------------------		// Configuring a View’s Visual Appearance		//------------------------------------				/**		 * Determines the background color of this view.		 */		public function set backgroundColor(value:uint):void{			if(value != m_backgroundColor){				m_backgroundColor = value;				if(value == -1){					this.graphics.clear();				}				this.setNeedsDisplay();			}		}		// 		public function get backgroundColor():uint{			return m_backgroundColor;		}				/**		 * Determines the background color of this view.		 */		public function set backgroundAlpha(value:Number):void{			if(value != m_backgroundAlpha){				m_backgroundAlpha = value;				if(value == -1){					this.graphics.clear();				}				this.setNeedsDisplay();			}		}		// 		public function get backgroundAlpha():Number{			return m_backgroundColor;		}				//------------------------------------		// Managing the View Hierarchy		//------------------------------------				/**		 * Returns the superview of this UIView instance if the superview is a UIView		 */		public function get superview():UIView{			return this.parent as UIView;		}				/**		 * Indicates the root window of this view hierarchy.		 */		public function get window():UIWindow{			if(this is UIWindow)return this as UIWindow;			return m_window;		}				/**		 * Removes this view instance from it superview.		 */		public function removeFromParent():void{			if(this.parent){				this.parent.removeChild(this);			}		}						//------------------------------------		// Getting and Setting View Attributes.		//------------------------------------				/**		 * Indicates the bounds of this UIView in it own cordinate space.		 * 		 * <p>The bounds are updated if changed on each render cycle.</p>		 */		public function get bounds():Rectangle{			return m_bounds.clone();		}				/**		 * Indicates the bounds of this UIView in it parent cordinate space.		 */		public function get frame():Rectangle{			return this.parent ? this.getBounds(this.parent) : null;		}				/**		 * An integer that can be used to identify the view in your application.		 * 		 * @default <code>0</code> 		 */		public function set tag(value:int):void{			m_tag = value;		}		// returns the tag of this view.		public function get tag():int{			return m_tag;		}				//------------------------------------		// COMMOND METHODS		//------------------------------------				/**		 * Destoyes the <code>View</code> instances and hopefully it´s collected by the Garbage Collector.		 * <p>All composite views are either destroyed or sent to a Object Pool for reuse.<br/>		 * All internal eventlistners are removed and the object is as much as posible destoryed.		 * <br/> an event type of "dispose" is dispatched as the view instance is destoyed</p>		 */		public function dispose():void{			this.dispatchEvent(new Event("dispose"));			// removes the viewport from the displaylist.			this.removeFromParent();			// kills the drawing cycle on this instance.			if(m_invalidated){				removeEventListener(Event.EXIT_FRAME,onInvalidation);			}			// removes nulling objects.			m_invalidates = null;			m_window = null;			m_bounds = null;		}				//------------------------------------		// Drawing Cycle		//------------------------------------				/**		 * Abstract method that renders the view. Any delayed rendering (invalidation) is aborted as this method is called.		 * <b>who to override</b> When overriding this method in subclasses make sure to call the 		 * super.render() in any the override (else there will be spill in the render stack),		 * but be aware that the invalidation data is destoyed after the super call.		 */		public function render():void{			// refreshing the frame of the view.			m_bounds.width = m_width;			m_bounds.height = m_height;			var renderRect:Rectangle = m_bounds.clone();			// calls the drawRect method.			if(isInvalidated(UIView.INVALIDATE_DISPLAY)){				draw(renderRect);			}			if(isInvalidated(UIView.INVALIDATE_LAYOUT)){				layout(renderRect);			}						// calls the onInvalidation if the view's render where trigger before the frame-delay.			if(m_invalidated)				onInvalidation(null,false);					this.dispatchEvent(new Event(Event.RENDER));			// temporary developer testing.			//trace("render "+this.toString()+" tag: "+m_tag+" @"+m_width+"x"+m_height);		}				/**		 * Invalidates the view, this forces the view to be redrawn on the next frame.		 * 		 * <p>This method can be invoked with a type argument to indicate to the render method		 * that the properity needs to be re-rendered. in a <code>render()</code> <code>override</code> 		 * you can check if a Property where invalidated with a code simular to this <code>invalidated("example")</code></p>		 * @param type The reference to be invoked with the <code>render()</code> method.		 */		core final function invalidate(type:String = null):void{			if(!m_invalidated){				addEventListener(Event.EXIT_FRAME,onInvalidation);				m_invalidated = true;			}			if(type != null){				m_invalidates[type] = true;			}		}				/**		 * Indicated that the view have been invailaded.		 * 		 * @param type If a <code>String</code> in passed then the method return if the type is invalidated. 		 * If no type argument is supplied the method returns if any type is invalidated		 */		core final function isInvalidated(type:String = null):Boolean{			if(type != null){				return(m_invalidates[type] != null);			}			return(m_invalidated);		}				/**		 * This respond method is a respond for invalidate, this method is called with one frame delay.		 * 		 * the defualt method triggerd by the onInvalidate method is the draw() method.		 * the call parameter is added so the render method can call this method wihtout making an eternal stack of calls.		 */		core final function onInvalidation(e:Event = null,call:Boolean = true):void{			// removes the eventlistner, for the next frame event.			removeEventListener(Event.EXIT_FRAME,onInvalidation);			m_invalidated = false;			if(call){				render();				}			m_invalidates = new Object();		}				/**		 * Specifies the properites that needs to be redrawn.		 * <p>The properities are set by the type argument in the <code>invalidate()</code> method.</p>		 */		core function get invalidates():Object{			return(m_invalidates)		}				//------------------------------------		// Laying out Subviews.		//------------------------------------				/**		 * Calling this method flags to the drawing cycle that the layout needs to be updated.		 */		public function setNeedsLayout():void{			this.invalidate(UIView.INVALIDATE_LAYOUT);		}				/**		 * Laying out subview inside the <code>rect</code> representing the new bounds of the view.		 * 		 * <p>The Default implementation of this method does nothing.		 * Subclasses can override this method as needed to perform more precise layout of their subviews.		 * You should never call this method directly. This method is by default invoked as the view is resized.</p>		 * 		 * @param rect The portion of the view's bounds that needs to be updated. By default this rectangle is represents the entire bounds of your view.		 */		public function layout(rect:Rectangle):void{					}				//------------------------------------		// Drawing and Updating the View		//------------------------------------				/**		 * Calling this method flags to the drawing cycle that the display needs to be updated.		 */		public function setNeedsDisplay():void{			this.invalidate(UIView.INVALIDATE_DISPLAY);		}				/**		 * Draws the content of the view within the passed-in rectangle.		 * 		 * <p>The default implementation of this method draws the background.		 * Subclasses that uses <code>flash.display.Graphics</code> (such as Core UI)		 * to draw their view's content should override this method and implement their		 * drawing code there. You do not need to override this method if your view		 * displays it's content in other ways. by default this method is invoked at 		 * a maximun of once per frame which keeps preformance usage down.</p>		 * 		 * @param rect The portion of the view's bounds that needs to be updated. By default this rectangle is represents the entire bounds of your view. 		 */		public function draw(rect:Rectangle):void{			if(m_backgroundColor != -1){				this.graphics.clear();				this.graphics.beginFill(m_backgroundColor,m_backgroundAlpha);				this.graphics.drawRect(0,0,rect.width,rect.height);				this.graphics.endFill();			}		}					//------------------------------------		// Added functionality.		//------------------------------------				/**		 * Moves the view to a specific point.		 * 		 * <p>Use this method to prevent that two resize event are dispatched when setting both with and height.</p>		 */		public function moveTo(x:Number,y:Number):void{			this.x = int(x);			this.y = int(y);		}				/**		 * Resizes the view by a new width and height.		 * 		 * <p>Use this method to prevent that two resize event are dispatched when setting both with and height.</p>		 */		public function resize(width:int,height:int):void{			// validating input.			width = width < 0 ? 0 : width;			height = height < 0 ? 0 : height;			// setting the actual width and height to be references by the render.			m_width = width;			m_height = height;			// invalidates and indicates size change.			invalidate(UIView.INVALIDATE_DISPLAY);			invalidate(UIView.INVALIDATE_LAYOUT);			this.dispatchEvent(new Event(Event.RESIZE));		}				//------------------------------------		// Override the default DisplayObject properties.		//------------------------------------				/*		public override function set x(value:Number):void{			super.x = int(value);		}				public override function set y(value:Number):void{			super.y = int(value);		}		*/				/**		 * @private		 */		public override function set width(value:Number):void{			value = int(value);			value = value < 0 ? 0 : value;			// validating changes to the render, is no need to redraw if the value is the same as before.			if(value == m_width)return;			m_width = value;			invalidate(UIView.INVALIDATE_DISPLAY);			invalidate(UIView.INVALIDATE_LAYOUT);			this.dispatchEvent(new Event(Event.RESIZE));		}		// returns the current widht of this component instance.		public override function get width():Number{			return(m_width);		}				/**		 * @private		 */		public override function set height(value:Number):void{			value = int(value);			value = value < 0 ? 0 : value;			// validating changes to the render, is no need to redraw if the value is the same as before.			if(value == m_height)return;			m_height = value;			invalidate(UIView.INVALIDATE_DISPLAY);			invalidate(UIView.INVALIDATE_LAYOUT);			this.dispatchEvent(new Event(Event.RESIZE));		}		// returns the current height of this component instance.		public override function get height():Number{			return(m_height);		}				//------------------------------------		// Overriding the default hieraki of the displaylist to reference the window instances.		//------------------------------------				override public function addChild(child:DisplayObject):DisplayObject{			child = super.addChild(child);			// manages the hieraky of windows.			var view:UIView = child as UIView;			if(view && !view is UIWindow)				view.attacthWindow(m_window);			// returns the child.			return child;		}				override public function addChildAt(child:DisplayObject, index:int):DisplayObject{			child = super.addChildAt(child,index);			// manages the hieraky of windows.			var view:UIView = child as UIView;			if(view && !view is UIWindow)				view.attacthWindow(m_window);			// returns the child.			return child;		}				override public function removeChild(child:DisplayObject):DisplayObject{			child = super.removeChild(child);			// manages the hieraky of windows.			var view:UIView = child as UIView;			if(view && !view is UIWindow)				view.attacthWindow(null);			// returns the child.			return child;		}				override public function removeChildAt(index:int):DisplayObject{			var child:DisplayObject = super.removeChildAt(index);			// manages the hieraky of windows.			var view:UIView = child as UIView;			if(view && !view is UIWindow)				view.attacthWindow(null);			// returns the child.			return child;		}				// adding and removeing the view from a hieraky represented by UIWindow(s).		private final function attacthWindow(window:UIWindow):void{			var view:UIView;			var len:int = this.numChildren;			for(var i:int = 0;i<len;i++){				view = this.getChildAt(i) as UIView;				if(view)					view.attacthWindow(window);			}			m_window = window;		}					}}