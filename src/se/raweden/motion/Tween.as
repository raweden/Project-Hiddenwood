package se.raweden.motion{	import flash.display.DisplayObject;	import flash.display.Shape;	import flash.events.Event;	import flash.utils.Timer;	import flash.utils.getTimer;
	/**	 * A <code>Tween</code> Object	 * 	 * @author Raweden.	 */	public class Tween{				//		// TODO: add support for updating properties automaticly.		// TODO: add snapToPixel/useSnap attribute to tweener.		//						// Class Variables.				private static var _tweens:Vector.<Tween> = new Vector.<Tween>;		private static var _swap:Array = [];		private static var _connected:Boolean = false;		private static var _running:Boolean;		private static var _lastTime:Number;		private static var _ticker:DisplayObject;	// references the stage (temporary a Shape) to get a frame ticker.		private static var _stage:DisplayObject;	// references the stage or temporary shape to get frame ticker. 				// Instance Variables.		private var _target:Object;		private var _properties:Vector.<TweenProperty>;		private var _transition:Function;		private var _started:Boolean = false;		private var _state:int;		// Instance time related variables (all values are in millisecounds).			private var _duration:Number;			// holds the duration of the animation.		private var _delay:Number;				// holds the animation delay time.		private var _startTime:Number;			// holds the time of when the animation where started.		private var _pauseTime:Number;			// holds the timestamp for when the animation where last paused.		private var _pauseOffset:Number = 0;	// holds the total time the animation have been paused.		// Callbacks.		private var _onStart:Function;		private var _onUpdate:Function;		private var _onComplete:Function;		// Callback Parameters		//private var _onStartParams:Array;		//private var _onUpdateParams:Array;		private var _onCompleteParams:Array;						/**		 * 		 * @param target		 * @param duration		 * @param properties		 * @param parameters		 */		public function Tween(target:Object,duration:Number,properties:Object,parameters:Object){			_target = target;						// Setting properties.			_properties = new Vector.<TweenProperty>;			for(var name:String in properties){				var value:Number = properties[name];				_properties.push(new TweenProperty(name,value));			}			// TODO: adopt and overwrite other tween's properties if needed here.						// Setting parameters.			_duration = duration*1000;;			_delay = 0;			_transition = Equations.none;						//trace("duration:",_duration);			// Setting Callbacks.						// Setting Custom parameters.			if(parameters){								// Determine delay.				value = parameters["delay"];				if(value is Number && !isNaN(value) )					_delay = value;								// Determine transition.				if(parameters["transition"] && parameters["transition"] is String){					name = parameters["transition"];					if(Equations[name] is Function){						_transition = Equations[name];					}				}else if(parameters["transition"] is Function){					_transition = parameters["transition"];				}								// Determine callbacks.				if(parameters["onStart"] && parameters["onStart"] is Function){					_onStart = parameters["onStart"];				}				if(parameters["onUpdate"] && parameters["onUpdate"] is Function){					_onUpdate = parameters["onUpdate"];				}				if(parameters["onComplete"] && parameters["onComplete"] is Function){					_onComplete = parameters["onComplete"];				}								// Determine callback parameters.				if(parameters["onCompleteParams"] && parameters["onCompleteParams"] is Array){					_onCompleteParams = parameters["onCompleteParams"]; 				}			}		}				/**		 * TEMPORARY IMPLEMENTATION TO DISPATCH onComplete, onUpdate and onStart.		 * 		 * @param type		 */				private function dispatch(type:int):void{			// temporary implementation to dispatch events.			switch(type){				case TweenEvent.UPDATE:{					if(_onUpdate != null)						_onUpdate();					break;				}				case TweenEvent.START:{					if(_onStart != null)						_onStart();					break;				}				case TweenEvent.COMPLETE:{					if(_onComplete != null)						if(_onCompleteParams){							_onComplete.apply(null,_onComplete);						}else{							_onComplete();							}					break;				}			}		}				//------------------------------------		// Controll the animation.		//------------------------------------				/**		 * Starts the animation.		 */		public final function start():void{			if(this.playing){				this.stop();			}			// throws this instance into the main loop.			var time:int = getTimer();			_pauseOffset 0;			_pauseTime = 0;			this.startInternal(time+_delay);			this.dispatch(TweenEvent.START);			// sets the current state of animation.			_state = TweenState.PLAYING;		}				/**		 * Starts the animation.		 * 		 * @param time Current time offset.		 */		private final function startInternal(time:Number = -1):void{			if(time != -1){				_startTime = time;				}			// connects the tween instance in the main-loop.			Tween.connect(this);		}				/**		 * Pauses the animation.		 */		public final function pause():void{			//trace("tween-paused");			if(this.stopped){				throw new Error("can't not pause a Tween which is currently stopped");			}			if(this.paused){				return;			}			// disconnects the tween instance from the main-loop.			Tween.disconnect(this);			_pauseTime = getTimer();			this.dispatch(TweenEvent.PAUSE);			// sets the current state of animation.			_state = TweenState.PAUSED;		}				/**		 * Resumes the animation after beeing stopped.		 */		public final function resume():void{			//trace("tween-resumed");			if(!this.paused){				throw new Error("Can't resume a Tween which isn't in a paused state.");			}			var time:int = getTimer();			_pauseOffset += (time - _pauseTime);			_pauseTime = 0;			this.startInternal();			this.dispatch(TweenEvent.RESUME);			// sets the current state of animation.			_state = TweenState.PLAYING;		}						/**		 * Stops the animation.		 */		public final function stop():void{			//trace("tween-stoped");			if(this.stopped){				return;			}			// disconnets the tween from the main run loop.			Tween.disconnect(this);			// implement a chain trigger transition here.			this.dispatch(TweenEvent.STOP);			// sets the current state of animation.			_state = TweenState.STOPPED;		}			/**		 * Disposes the Tween instance to deallocate memory space.		 */		private final function dispose():void{			if(_properties != null){				while(_properties.length > 0){					_properties.shift();				}			}			_properties = null;			_transition = null;		}						//------------------------------------		// Getting and Setting Attributes.		//------------------------------------				/**		 * 		 */		public final function set delay(value:Number):void{			if(value < 0) throw new ArgumentError("Duration can't be less than 0");			_delay = value*1000;		}		// returns the current duration.		public final function get delay():Number{			return _delay/1000;		}				/**		 * 		 */		public final function set duration(value:Number):void{			if(value < 0) throw new ArgumentError("Duration can't be less than 0");			_duration = value*1000;		}		// returns the current duration.		public final function get duration():Number{			return _duration/1000;		}						//------------------------------------		// Getting Current State		//------------------------------------				/**		 * A Boolean value that determine whether the <code>Tween</code> instance is currently playing.		 */		public final function get playing():Boolean {			return _state == TweenState.PLAYING;		}				/**		 * A Boolean value that determine whether the <code>Tween</code> instance is currently paused.		 */				public final function get paused():Boolean {			return _state == TweenState.PAUSED;		}				/**		 * A Boolean value that determine whether the <code>Tween</code> instance is in a idle state.		 */		public final function get idle():Boolean {			return _state == TweenState.IDLE;		}				/**		 * A Boolean value that determine whether the <code>Tween</code> instance is currently stopped.		 */		public final function get stopped():Boolean {			return _state == TweenState.STOPPED;		}				//------------------------------------		// Overwrite Manager		//------------------------------------				/**		 * Determine whether anohter tween instance is targeting the same object.		 */		private static function hasTween(target:Object):Boolean{			var len:int = _tweens.length;			var tween:Tween;			for(var y:int = 0;y<len;y++){				tween = _tweens[y];				if(tween && tween._target == target){					return true;				}			}			return false;		}				/**		 * Adopts (overwrits) common poroperties for tweens with the same target.		 * 		 * @param target		 * @param names		 * @return Vector containing TweenProperty of the common name.		 */				private static function adoptProperties(target:Object, names:Array):Vector.<TweenProperty>{			var properties:Vector.<TweenProperty> = new Vector.<TweenProperty>;			var p:TweenProperty;			var len:int = _tweens.length;			var tween:Tween;			for(var y:int = 0;y<len;y++){				tween = _tweens[y];				if(tween && tween._target == target){					// interceptors over the properties of that tween to fint common properties.					for(var x:int = 0;x<tween._properties.length;x++){						p = tween._properties[x];						// if common property is fount the older tween transfears the ownership to the new tween.						if(names.indexOf(p.name) != -1){							properties.push(p);							tween._properties.splice(x,1);							x--;						}						}				}			}			return properties.length > 0 ? properties : null;		}				//------------------------------------		// Tweeen Animation Run-Cycle.		//------------------------------------				/**		 * Update interceptors.		 */		private final function update(time:int):Boolean{			var t:Number;			var i:int;			var len:int = _properties.length;			var p:TweenProperty;			// getting time related values.			var loc:Number = _startTime + _pauseOffset;		// local time offset.			var end:Number = loc + _duration;			if(_started || time >= _startTime){								if(!_started){					// Animation not yet started.									dispatch(TweenEvent.START);										// Property value not initialized yet.					for(i = 0; i<len; i++){												p = _properties[i];												// gets the starting value (borrow the t variable to read vars).						t = _target[p.name];												// Reads the start value.						p.start = isNaN(t) ? p.value : t;												// carculates the step value. @TODO: remove values without a step == 0.						p.step = p.value - p.start;					}					_started = true;					dispatch(TweenEvent.UPDATE);					//trace("tween-started");					return true;				}								if(time >= end){					// Animationn time has finished, just set it to the final value.					for(i = 0; i<len; i++){						p = _properties[i];						_target[p.name] = p.value;					}										dispatch(TweenEvent.UPDATE);					dispatch(TweenEvent.COMPLETE);					//trace("tween-completed");					return false;				}else{					// Animation continues. t is the time aspect value (0.0 - 1.0).					t = _transition((time - loc)/_duration);					for(i = 0; i<len; i++){						p = _properties[i];						_target[p.name] = p.start + (t * p.step);					}					//trace("tween-updated (t = "+(t)+")");					dispatch(TweenEvent.UPDATE);				}			}						return true;		}				/**		 * 		 */		private static function onEnterFrame(e:Event):void{			var i:int = 0;			var len:int;			_running = true;			var time:int = getTimer();			if(time == _lastTime){				return;			}			// runs the update method for all connected Tweens			len = _tweens.length;			while(i < len){				if(_tweens[i].update(time) == false){					_tweens[i].dispose();					_tweens.splice(i, 1);					len--;					i--;				}				i++;			}			// Determine whether the tween should disconnect.			if(_tweens.length == 0 && _connected){				// removes the eventlistners to the ticker.				ticker.removeEventListener(Event.ENTER_FRAME,onEnterFrame);				_connected = false;				//trace("Tween-disconnected");			}			_running = false;			_lastTime = time;		}				/**		 * The ticker used for frame based animation.		 */		private static function set ticker(value:DisplayObject):void{			if(value && _ticker && _connected){				_ticker.removeEventListener(Event.ENTER_FRAME,onEnterFrame);				_ticker = value;				_ticker.addEventListener(Event.ENTER_FRAME,onEnterFrame);			}else if(value){				_ticker = value;			}		}		// returns the current enter frame ticker.		private static function get ticker():DisplayObject{			if(!_ticker){				_ticker = new Shape();			}			return _ticker;		}				//------------------------------------		// Manage Tween Run cycle.		//------------------------------------				/**		 * Connects a tween to the update interceptor.		 * 		 * @param tween The tween object to be connected to the update interceptor		 */		private static function connect(tween:Tween):void{			var index:int = _tweens.indexOf(tween);			if(index != -1){				return;			}			index = _swap.indexOf(tween);			if(index != -1){				_swap.splice(index,1);			}			// Determine if stage reference is avaible.			if(!_connected){				// adds the eventlistner to be triggerd on each frame.				ticker.addEventListener(Event.ENTER_FRAME,onEnterFrame);				_connected = true;				//trace("Tween-connected");			}			_tweens.push(tween);		}		/**		 * Disconnects a tween from the update interceptor.		 * 		 * @param tween The tween object to be disconnected from the update interceptor.		 * @param remove A boolean value that determines whether the tween will be removed or moved to swap.		 */		private static function disconnect(tween:Tween,remove:Boolean = false):void{			if(!remove){				_swap.push(tween);			}			var index:int = _tweens.indexOf(tween);			if(index == -1){				return;			}			_tweens.splice(index,1);			if(_tweens.length == 0 && _connected){				// removes the eventlistners to the ticker.				ticker.removeEventListener(Event.ENTER_FRAME,onEnterFrame);				_connected = false;				//trace("Tween-disconnected");			}		}				//------------------------------------		// Create Tween instances.		//------------------------------------				/**		 * 		 * @param target		 * @param duration		 * @param properties		 * @param parameters		 * 		 * @return The tween object.		 */		public static function to(target:Object,duration:Number,properties:Object,parameters:Object = null):Tween{			//trace("adding tween with duration:",duration);			var tween:Tween = new Tween(target,duration,properties,parameters);			tween.start();			return tween;		}					}}/** * Constants that is dispatched to the observers <code>onTweenEvent()</code> method. *  * @author Raweden. */class TweenEvent{		public static const COMPLETE:int = 0;	public static const UPDATE:int = 1;	public static const START:int = 2;	public static const STOP:int = 4;	public static const PAUSE:int = 8;	public static const RESUME:int = 16;	}/** * Constants used by the <code>Tween</code> to represents it's current state. *  * @author Raweden. */class TweenState{		public static const IDLE:int = 1;	public static const PLAYING:int = 2;	public static const STOPPED:int = 3;	public static const PAUSED:int = 4;	}