package se.raweden.filesystem{	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.net.NetConnection;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.utils.ByteArray;		import se.raweden.events.WebFileEvent;	import se.raweden.net.RemoteMessage;	import se.raweden.utils.DateUtil;		/**	 * Dispatched when the <code>WebFile</code> reference is created.	 */	[Event(name="created", type="se.raweden.events.WebFileEvent")]		/**	 * Dispatched when the <code>WebFile</code> have resived a node list over it's reference.	 */	[Event(name="listing", type="se.raweden.events.WebFileEvent")]		/**	 * Dispatched when the <code>WebFile</code> have resived meta-data attributes relative to the reference.	 */	[Event(name="metaData", type="se.raweden.events.WebFileEvent")]		/**	 * Dispatched when the <code>WebFile</code>'s have been moved to another location.	 */	[Event(name="moved", type="se.raweden.events.WebFileEvent")]		/**	 * Dispatched when the <code>WebFile</code>'s reference have been noticed to be removed.	 */	[Event(name="removed", type="se.raweden.events.WebFileEvent")]		/**	 * Dispatched when the <code>WebFile</code>'s reference has been updated.	 */	[Event(name="updated", type="se.raweden.events.WebFileEvent")]		/**	 * Dispatches when the <code>WebFile</code> have resived information about the reference.	 */	[Event(name="init", type="flash.events.Event")]		/**	 * Dispatches when the content of <code>WebFile</code> have been loaded completly.	 */	[Event(name="complete", type="flash.events.Event")]		/**	 * A <code>WebFile</code> is a reference object for remote located files and directories.	 * 	 * <p>Copyright 2011, Raweden. All Rights Reserved.</p>	 * 	 * @author Raweden	 */	public final class WebFile extends EventDispatcher implements IFileReader{		// meta-data properties.		private var _exists:Boolean;		private var _isDirectory:Boolean;		private var _modificationDate:Date;		private var _name:String;		private var _path:String;		private var _length:Number;		private var _type:String;				// Reference to related meta-data objects.		private var _bundle:WebFileBundle;		private var _parent:WebFile;		private var _nodes:Array;		private var retrived:Boolean = false;				// content reference.		private var _data:*				/**		 * Constructor.		 * 		 * @param path		 * @param connection		 */		public function WebFile(path:String,connection:NetConnection){			super();			if(connection){				_bundle = WebFileBundle.connect(connection,rootConstructor);				_path = path;			}		}				/**		 * 		 */		private function rootConstructor(attributes:Object):WebFile{			trace("web-file-bundle is root:",_path && _path == attributes.root.path);			var root:WebFile;			if(attributes.root){				if(_path && _path == attributes.root.path){					root = this;				}else{					root = new WebFile(null,null);					root._bundle = _bundle;					root._path = attributes.root.path;				}							root._exists = true;				root._name = attributes.root.name;				root._isDirectory = attributes.root.is_dir;				root._modificationDate = DateUtil.from(attributes.root.mtime);				root.dispatchEvent(new Event(Event.INIT));				root.retrived = true;				return root;			}			return null;		}			//------------------------------------		// Getting Attributes.		//------------------------------------				/**		 * 		 */		public final function get connection():NetConnection{			return _bundle ? _bundle.connection : null;		}						/**		 * A <code>Boolean</code> value taht determine whether the reference of this 		 * <code>WebFile</code> exists. This value will always be <code>false</code> until the		 * referd data is fetched from the remote server.		 */		public final function get exists():Boolean{			return _exists;		}				/**		 * A <code>Boolean</code> value that determine whether this instance reference is to a		 * directory.		 */		public final function get isDirectory():Boolean{			return _isDirectory;		}				/**		 * Indicates the date when the referenced file or directory where last modified.		 * 		 * <p>If the data refering to this reference have not been fetched from the remote system.		 * the value of this property is null.</p>		 */		public final function get modificationDate():Date{			return _modificationDate ? new Date(_modificationDate) : null;			}				/**		 * Indicates the name of the file or directory which this instance is a reference to.		 * 		 * <p>If the data refering to this reference have not been fetched from the remote system.		 * the value of this property is null.</p>		 */		public final function get name():String{			return _name;		}				/**		 * Indicates the parent directory reference for this <code>WebFile</code>.		 */		public final function get parent():WebFile{			return retrived ? _parent : null;		}				/**		 * Indicates the path of the referenced file or directory.		 * 		 * <p>If the data refering to this reference have not been fetched from the remote system.		 * the value of this property is null.</p>		 */		public final function get path():String{			return retrived ? _path : null;		}				/**		 * Indicates the root of this file bundle represented as a <code>WebFile</code> instance.		 */		public final function get root():WebFile{			return _bundle ? _bundle.root : null;		}				/**		 * Determine the size of the referenced file in bytes. The value of this property will 		 * always be code>-1</code> when referencing a directory.		 */		public final function get length():Number{			return _length;		}				/**		 * Indicates the filename extention for the content that this <code>WebFile</code>		 * references.		 */		public final function get type():String{			return _type;		}				/**		 * Contains the childs nodes references for a directory. This property is set after the		 * child list is fetched and resived from remote system.		 */		public final function get nodes():Array{			return _nodes ? _nodes.concat() : null;		}				/**		 * Indicates the web server url of the referenced.		 * 		 * <p>If the data refering to this reference have not been fetched from the remote system.		 * the value of this property is null.</p>		 */		public final function get url():String{			return retrived && _path && _bundle.url ? (_bundle.url+_path) : null;		}				//------------------------------------		// Loading Wrapper Contents.		//------------------------------------				/**		 * @inheritDoc		 */		public function get data():*{			return _data;		}				/**		 * @inheritDoc		 */		public function load():void{			if(!_data){				var message:RemoteMessage = new RemoteMessage(connection, "WebFile.getFile", onLoaded, _path);				message.send();				}		}				/**		 * @inheritDoc		 */		public function cancel():void{		}				private function onLoaded(data:Object,message:RemoteMessage):void{			trace("resived data from "+this+" is "+(data is ByteArray ? "binary" : data is String ? "string" : "unsupported type"));			var bytes:ByteArray;			if(_data is ByteArray){				_data = data;			}else if(_data is String){				bytes = new ByteArray();				bytes.writeUTFBytes(data as String);				_data = bytes;			}			this.dispatchEvent(new Event(Event.COMPLETE));		}				/**		 * 		 * 		 * @param incremental 		 */		public final function save(incremental:Boolean = false):void{			var connection:NetConnection = _bundle ? _bundle.connection : null;						// ensures that the operation is possible.			if(_bundle && connection){				var message:RemoteMessage = new RemoteMessage(connection, "WebFile.putFile", onSave, _path, _data, incremental);				message.send();			}		}				private function onSave(data:Object,message:RemoteMessage):void{			trace("user did login");			for(var p:String in data){				trace(p+":",data[p]);			}			trace("write:",data);		}				//------------------------------------		// Managing Wrapper 		//------------------------------------		/**		 * 		 * @param parent The parent directory to move the referenced file or directory.		 */		public final function moveTo(parent:WebFile):void{			var connection:NetConnection = _bundle ? _bundle.connection : null;						// ensures that the operation is possible.			if(connection && _bundle && _bundle.equalTo(parent._bundle)){				var message:RemoteMessage = new RemoteMessage(connection, "WebFile.moveTo", onMove, _path, parent._path);				message.send();			}		}						/**		 * 		 * @param target The target reference that will be created or replaced by a copy of the content which this <code>WebFile</code> references.		 */		public final function copyTo(parent:WebFile):WebFile{			var connection:NetConnection = _bundle ? _bundle.connection : null;						// ensures that the operation is possible.			if(connection && _bundle && _bundle.equalTo(parent._bundle)){				var message:RemoteMessage = new RemoteMessage(connection, "WebFile.copyTo", onCopy, _path, parent._path);				message.send();			}			return null;		}						/**		 * Removes the content which this <code>WebFile</code> references.		 */		public final function remove():void{			var connection:NetConnection = _bundle ? _bundle.connection : null;			if(connection){				var message:RemoteMessage = new RemoteMessage(connection, "WebFile.remove", onRemove, _path);				message.send();			}		}							/**		 * 		 */		public final function directoryListing():void{			var connection:NetConnection = _bundle ? _bundle.connection : null;						// ensures that the operation is possible.			if(_bundle && connection){				var message:RemoteMessage = new RemoteMessage(connection, "WebFile.metadata", onDirectoryListing, _path);				message.send();			}		}						/**		 * Creates a new directory at the location which this <code>WebFile</code> references.		 * 		 * @param name The name of the new directory.		 * @return 		 */		public final function createDirectory(name:String):WebFile{			var connection:NetConnection = _bundle ? _bundle.connection : null;						// ensures that the operation is possible.			if(_isDirectory && _bundle && connection){								// appending the name to path component.				var parts:Array = _path.split("/");				parts.push(name);				var path:String = parts.join("/");								// creating file reference.				var ref:WebFile = new WebFile(null,null);				ref._parent = this;				ref._bundle = _bundle;								// sending message to collab.				var message:RemoteMessage = new RemoteMessage(connection, "WebFile.createFolder", ref.onMakeDir, path, null);				message.send();								return ref;			}			return null;		}				//------------------------------------		// Responder to Service Interaction.		//------------------------------------				/**		 * This method handles the server response to WebFile.copyTo method.		 */		private final function onCopy(data:Object,message:RemoteMessage):void{			trace("onCopy where triggerd with: "+data+" from method-message: "+message);		}				/**		 * This method handles the server response to WebFile.directoryListing() method.		 */		private final function onDirectoryListing(data:Object,message:RemoteMessage):void{			trace("method where resived");			var items:Array = data as Array;			var node:WebFile;			var vo:Object;			var len:int = items.length;			_nodes = [];			while(items.length > 0){				vo = items.shift();				node = new WebFile(null,null);				// Setting private properties from value object.				node._exists = vo.exists;				node._modificationDate = vo.mtime ? DateUtil.from(vo.mtime) : null;				node._isDirectory = vo.is_dir;				node._length = vo.is_dir ? -1 : vo.size;				node._name = vo.name;				node._path = vo.path;				node._type = vo.is_dir ? null : String(String(vo.name).split(".").pop()).toLowerCase();				// Setting private properties from inher				node._bundle = _bundle;				node._parent = this;				node.retrived = true;				// Pushing the node into nodes array.				_nodes.push(node);			}			this.dispatchEvent(new WebFileEvent(WebFileEvent.LISTING));		}				/**		 * This method handles the server response to WebFile.moveTo() method.		 */		private final function onMove(data:Object,message:RemoteMessage):void{			this.dispatchEvent(new WebFileEvent(WebFileEvent.MOVED));		}				/**		 * This method handles the server response to WebFile.remove() method.		 */		private final function onRemove(data:Object,message:RemoteMessage):void{			this.dispatchEvent(new WebFileEvent(WebFileEvent.REMOVED));		}				/**		 * This method handles the server response to WebFile.createDirectory() method.		 */		private final function onMakeDir(data:Object,message:RemoteMessage):void{			if(data != false){				this._exists = data.exists;				this._modificationDate = data.mtime ? DateUtil.from(data.mtime) : null;				this._isDirectory = data.is_dir;				this._length = data.size;				this._name = data.name;				this._path = data.path;				// Adds the created child to the parent nodes list.				if(_parent && _parent._nodes){					_parent._nodes.push(this);				}				// Dispatch a create event.				this.dispatchEvent(new WebFileEvent(WebFileEvent.CREATED));			}		}				//------------------------------------		// Pasteboard writer and Reader.		//------------------------------------				/**		 * @inheritDoc		 */		override public function toString():String{			return "[WebFile @\""+_path+"\" rpc = \""+(_bundle && _bundle.connection ? _bundle.connection.uri : "null")+"\" ]";		}			}}import flash.net.NetConnection;import se.raweden.filesystem.WebFile;import se.raweden.net.RemoteMessage;/** * The WebFileBundle manages a bundle of file which uses the same NetConnection to interact * with remote filesystem services. */class WebFileBundle{		private static var m_instances:Vector.<WebFileBundle> = new Vector.<WebFileBundle>;	private var m_connection:NetConnection;	private var rootConstructor:Function;	private var m_root:WebFile;	private var m_url:String;		public static function connect(connection:NetConnection,rootConstructor:Function):WebFileBundle{		var len:int = m_instances.length;		var bundle:WebFileBundle;		for(var i:int = 0;i<len;i++){			bundle = m_instances[i];			if(bundle.connection == connection){				return bundle;			}		}		// creates a new bundle.		bundle = new WebFileBundle(connection);		var message:RemoteMessage = new RemoteMessage(connection, "WebFile.bundle", bundle.init);		message.send();		bundle.rootConstructor = rootConstructor;		m_instances.push(bundle);		return bundle;	}	/**	 * Constructor (Private), use connect() instead.	 */	public function WebFileBundle(connection:NetConnection){		m_connection = connection;	}		private function init(data:Object,message:RemoteMessage):void{		trace("bundle data resived");		for(var p:String in data){			trace("bundle."+p+":",data[p]);		}				m_url = data.url;		// Sending attributes to completion handler.		if(rootConstructor != null){			m_root = rootConstructor(data);		}		rootConstructor = null;	}		/*	{	"max_upload_size":"32M",	"url":"http://localhost",	"root":		{		"path":"/",		"exists":true,		"name":"deploy",		"is_dir":true,		"mtime":1325618961		}	}		*/		/**	 * Indicates the connection used for remoting call by this file bundle.	 */	public final function get connection():NetConnection{		return m_connection;	}		/**	 * Indicates the root instance for the file bundle.	 */	public final function get root():WebFile{		return m_root;	}		/**	 * Indicates the base url for the root reference.	 */	public final function get url():String{		return m_url;	}		/**	 * Determine whether this bundle is mirrored on the equal location as the bundle in the argument.	 * 	 * @return A Boolean value that indicating whether the bundles are at the equal service locations.	 */	public final function equalTo(bundle:WebFileBundle):Boolean{		return (bundle && m_connection && bundle.m_connection) && m_connection.uri == bundle.m_connection.uri;	}	}