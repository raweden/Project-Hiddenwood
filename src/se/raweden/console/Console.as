package se.raweden.console{		/**	 * The <code>Console</code> provides a central command-line shell.	 * 	 * <p>Copyright 2011, Raweden. All Rights Reserved.</p>	 * 	 * @author Raweden	 */	public class Console{		//		// TODO: develop a better way to strip of the quites ("") from encapsulted arguments.		//				private static const _commands:Array = [];		private static var _initialized:Boolean;			private static var _client:IConsoleClient;				// reference to the master bash client.		private static var _buffer:String = "";				// holds the raw text as string before any client is set.		private static var _hasBuffer:Boolean;					// indicates if there is any buffer.		private static var _outputs:Vector.<IConsoleOutput>;				/**		 * 		 */		public static function initialize(client:IConsoleClient = null):void{			if(_initialized)return;			// initlizes the static variables.			_outputs = new Vector.<IConsoleOutput>;			// register the default commands.			registerCommand(ConsoleFoundation.helpUtils(_commands));			registerCommand(ConsoleFoundation.classUtils);			registerCommand(ConsoleFoundation.fontUtils);			_initialized = true;			if(client)				Console.client = client;		}				//------------------------------------		// Getting and Setting Attributes.		//------------------------------------			/**		 * Specifies the master Bash client.		 */		public static function set client(value:IConsoleClient):void{			initialize();			_client = value;		}		// indicates the current master client.		public static function get client():IConsoleClient{			return(_client);		}				/**		 * Returns the Output of the master bash client.		 */		public static function get text():String{			return _client ? _client.currentOutput : null;		}				//------------------------------------		// Managing Bash Outputs		//------------------------------------				/**		 * 		 * 		 * @param output		 */		public static function addOutput(output:IConsoleOutput):void {			if (_outputs.indexOf(output) == -1){				_outputs.push(output);			}		}				/**		 * 		 * 		 * @param output 		 */		public static function removeOutput(output:IConsoleOutput):void {			var index:int = _outputs.indexOf(output);			if(index == -1){				return;			}			_outputs.splice(index,1);		}				/**		 * Determine whether the output is registerd.		 * 		 * @param output		 * 		 * @return A <code>Boolean</code> value that determine whether the console have the output registerd.		 */		public static function hasOutput(output:IConsoleOutput):Boolean{			return _outputs.indexOf(output) != -1;		}				//------------------------------------		// Managing Writting and Command-line Output.		//------------------------------------				/**		 * Clears the output on the client and all Outputs.		 */		public static function clear():void{			_client.clear();			var len:int = _outputs.length;			for(var i:int = 0;i<len;i++){				_outputs[i].clear();			}		}				/**		 * Writes text to the output and clients without a linebreak.		 * 		 * @param args		 */		public static function write(... args:*):void{			var str:String = print(args);			if(!_initialized){				_buffer += str;				_hasBuffer = true;				return;			}			// writes the main client.			_client.write(str);			// writes the outputs.			var len:int = _outputs.length;			for(var i:int = 0;i<len;i++){				_outputs[i].write(str);			}			// implement auto show here.		}				/**		 * Writes text line to the client and all outputs, the line is ended with a linebreak.		 */		public static function writeLine(... args:*):void{			var str:String;			if(args is Array){				str = print(args);			}else{				str = String(args);			}			trace(str,args is Array);			if(!_initialized){				_buffer += str+"\n";				_hasBuffer = true;				return;			}			// writes the main client.			_client.write(str + "\n");			// writes the outputs.			var len:int = _outputs.length;			for(var i:int = 0;i<len;i++){				_outputs[i].write(str);			}			// implement auto show here.		}				/**		 * Writes the message from a Error to the clients and all outputs.		 */		public static function writeError(error:Error) : void {			writeLine(error.message,error.getStackTrace());		}				// prints the arguments sent to write and writeLine methods.		private static function print(args:Array):String{			var len:int = args.length;			var end:int = len-1;			var str:String = "";			for(var i:int = 0;i<len;i++){				str += "" + args[i];				str += (len != end) ? " " : "";			}			return(str);		}				//------------------------------------		// Command Execution Implementation		//------------------------------------		/**		 * Execute a command. This is the central method for executing registerd command.		 * 		 * @param name The trigger name of the command. 		 * @param args The collection of string arguments to invoke the command with.		 * 		 * @return A string feedback from the command or null if the command where not found, a actual response		 * is printed to all output indicating that the command where not found.		 * 		 */		public static function execute(name:String,...args:*):String{			trace("-bash: \""+name+"\""+(args.length > 0 ? " with arguments:"+args.toString() : ""));			var len:int = _commands.length;			var cmd:IConsoleCommand;			// looping the through the commands..			for(var i:int = 0;i<len;i++){				if(_commands[i].name == name){					cmd = _commands[i] as IConsoleCommand;					break;				}							}			// where a command with the name found?			if(cmd){				return cmd.execute.apply(cmd,args);				// alternative solution.				if(args.length < cmd.lenght){					return "-bash: "+name+": incorrect numbers of arguments";				}else{					return cmd.execute.apply(null,args);					}			}else{				return "-bash: "+name+": command not found";				}						// -bash: rawa: command not found			return(null);		}				/**		 * Extracts arguments from a string, validates and executes the request.		 * The arguments are executed using the <code>Bash.execute()</code> mehtod. 		 * 		 * @param line A string containing a single action to be executed.		 * 		 * @return The command string output.		 */		public static function exec(line:String):String{			// check if string is null.						// extracts the commands+arguments form the line.			var args:Array = new Array();			// extracts the segments of the line.			line.replace(/"(.*?)"|([\S]+)/g,extractor)	// old pattern extractor.. line.replace(/"(.*?)"|(\b[\w].*?\b)/g,extractor);						// function called to collect the arguments and command name.			function extractor(substr:String,capt:String,pos:int,full:String,s:*):void{				capt = capt == "" ? substr : capt;				args.push(capt);			}			// executes the command.			// TODO: validate the input, the command may not be null			return execute.apply(null,args);		}				//------------------------------------		// Managing Bash Commands.		//------------------------------------				/**		 * Register a new command to be used with the bash.		 *		 * @param command The command to register, the name parameter of the command must be uniqe.		 * @throws Error if the name of the command to register already exists.		 */		public static function registerCommand(command:IConsoleCommand):void {			var len:int = _commands.length;			var cmd:IConsoleCommand			for(var i:int = 0;i<len;i++){				cmd = _commands[i];				if(cmd.name == command.name){					throw new Error("Command with the same name alerady exists.");				}			}			_commands.push(command);			_commands.sortOn("name",Array.CASEINSENSITIVE);		}				/**		 * Unregister and removes the command from the console.		 * 		 * @param command The command to be removed and unregisterd.		 * 		 * @return A <code>Boolean</code> value that determine if the command where removed.		 */		public static function unregisterCommand(command:IConsoleCommand):Boolean{			var index:int = _commands.indexOf(command);			if(index != -1){				_commands.splice(index,1);				return true;			}			return false;		}			}}