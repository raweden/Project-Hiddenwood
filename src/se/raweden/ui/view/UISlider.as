package se.raweden.ui.view{		import flash.display.DisplayObjectContainer;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Rectangle;		import se.raweden.motion.Tween;
		/**	 * A <code>UISlider</code> component is a visual control used to select a single inbetween a range of values.	 * Sliders are always displyad as horizontal bars. 	 * 	 * 	 * <p>Copyright 2011 Raweden. All rights reserved.</p>	 * 	 * @author Raweden	 */	public class UISlider extends UIControl{				//		// TODO: add means for customization in the skin.		// TODO: move thumb to correct value when slider is resized.		//				public static const DIRECTION_VERTICAL:String = "vertical";		public static const DIRECTION_HORIZONTAL:String = "horizontal";				private var _value:Number = 0;		private var _continuous:Boolean;		private var _isVertical:Boolean = false;		// hit reference for the smooth draging.		private var hitX:int;		private var hitY:int;				// Related Views.		private var track:Sprite;		private var thumb:Sprite;				/**		 * Constructor.		 * 		 * @param parent		 */		public function UISlider(parent:DisplayObjectContainer = null){			super(parent);			// initilizes this instance.			addChildren();			init();		}				/**		 * Creates and adds related view instances.		 */		private function addChildren():void{			// creating the track.			track = new Sprite();			track.y = 5;			track.addEventListener(MouseEvent.CLICK,onTrackClick);			this.addChild(track);			// creating the thumb.			thumb = new Sprite();			thumb.addEventListener(MouseEvent.MOUSE_DOWN,dragStart);			this.addChild(thumb);		}				/**		 * Instance initilization.		 */		private function init():void{			// setting the default size.			resize(100,16);			render();		}				//------------------------------------		// Responding to User Interaction		//------------------------------------				/**		 * Triggerd when the track is clicked (this scrubs the thumb to the positon clicked).		 */		private function onTrackClick(e:MouseEvent):void{			var x:int = track.mouseX;			var procent:Number = x/track.width;			this.setValue(procent,true);		}				/**		 * Triggerd when the user presses down the handle.		 */		private function dragStart(e:MouseEvent):void{			hitX = thumb.mouseX;			hitY = thumb.mouseY;			stage.addEventListener(MouseEvent.MOUSE_MOVE,dragMove);			stage.addEventListener(MouseEvent.MOUSE_UP,dragStop);		}				/**		 * Triggerd when the mouse moves over the stage after the handle have been pressed down.		 */		private function dragMove(e:MouseEvent):void{			var max:int = track.width-thumb.width;			var min:int = 0;			var v:int;			v = mouseX-hitX;			v = v < min ? min : v;			v = v > max ? max : v;			thumb.x = v;			var procent:Number = v/max;			// dispatches the change event if the behavior is set.			if(continuous && procent != _value){				this.dispatchEvent(new Event(Event.CHANGE));			}			_value = procent;			e.updateAfterEvent();		}				/**		 * Triggerd when the mouse relases over the stage after the handle have been pressed down.		 */		private function dragStop(e:MouseEvent):void{			stage.removeEventListener(MouseEvent.MOUSE_MOVE,dragMove);			stage.removeEventListener(MouseEvent.MOUSE_UP,dragStop);			if(!continuous){				this.dispatchEvent(new Event(Event.CHANGE));			}		}				//------------------------------------		// Accessing the Slider’s Value		//------------------------------------				/**		 * A Number representing the value manipulated by the slider. 		 * The value ranges from 0.0 to 1.0		 * 		 * @default <code>0.0</code>		 */		public function set value(value:Number):void{			setValue(value,stage != null);					}		// returns the value of the value attribute.		public function get value():Number{			return(_value);		}						/**		 * 		 */		public function setValue(value:Number,animated:Boolean = true):void{			value = value > 1 ? 1 : value;			value = value < 0 ? 0 : value;			var x:int = (track.width-thumb.width)*value;			trace("track-width:",track.width);			trace("x:",x);			if(animated && stage){				// Staring animation.				Tween.to(thumb,0.3,{x:x},{onComplete: onComplete,onUpdate: onUpdate}).start();			}else{				thumb.x = x;				_value = value;				this.dispatchEvent(new Event(Event.CHANGE));			}		}				//------------------------------------		// Private Method Responding to Animation Changes.		//------------------------------------				/**		 * Triggerd when the animation is updates the position for the handle.		 */		private function onUpdate():void{			// updating the procentage value.			_value = thumb.x/(track.width-thumb.width);			trace("value:",value);			// dispatching change if continuous 			if(continuous)				this.dispatchEvent(new Event(Event.CHANGE));			//this.setNeedsDisplay();		}				/**		 * Triggerd when the animation is complete.		 */		private function onComplete():void{			_value = thumb.x/(track.width-thumb.width);					}				//------------------------------------		// Modifying the Slider’s Behavior		//------------------------------------				/**		 * 		 * @default <code>false</code>		 */		public function set continuous(value:Boolean):void{			_continuous = value;		}		// returns the value of the continous attribute.		public function get continuous():Boolean{			return _continuous;		}				/**		 * Specifies the direction of the UISlider.		 * 		 * @default <code>UISlider.DIRECTION_HORIZONTAL</code>		 */		public function set direction(value:String):void{			var v:Boolean = value != DIRECTION_HORIZONTAL ? false : true;			if(v != _isVertical){				if(v){					resize(this.height,this.width);					this.needsDraw();				}else{					resize(this.height,this.width);					this.needsDraw();				}			}		}		// returns the value of the direction attribute.		public function get direction():String{			return _isVertical ? DIRECTION_VERTICAL : DIRECTION_HORIZONTAL;		}				//------------------------------------		// Updating Content Displayed.		//------------------------------------				/**		 * @inheritDoc		 */		override protected function draw(rect:Rectangle):void{			// drawing the minimal track.			track.graphics.clear();			track.graphics.beginFill(0xCCCCCC);			track.graphics.drawRoundRect(0,0,rect.width,6,6,6);			track.graphics.endFill();			// drawing the thumb.			thumb.graphics.clear();			thumb.graphics.beginFill(0xEDEDED);			thumb.graphics.drawEllipse(0,0,rect.height,rect.height);			thumb.graphics.endFill();		}				/**		 * @inheritDoc		 */		override protected function layout(rect:Rectangle):void{			thumb.x = Math.round((track.width-thumb.width)*_value);		}				//------------------------------------		// Deconstruction		//------------------------------------				/**		 * @inheritDoc		 */		override public function dispose():void{			// removing eventlistners.			track.removeEventListener(MouseEvent.CLICK,onTrackClick);			thumb.removeEventListener(MouseEvent.MOUSE_DOWN,dragStart);			// destoying the super implemenation.			super.dispose();		}			}}