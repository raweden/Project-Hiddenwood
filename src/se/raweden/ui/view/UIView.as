package se.raweden.ui.view{		import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Point;	import flash.geom.Rectangle;		import se.raweden.desktop.UIDragging;	import se.raweden.desktop.UIPasteboard;	import se.raweden.ui.events.UIEvent;	import se.raweden.ui.gesture.Gesture;	import se.raweden.utils.IDisposable;		/**	 * Dispatched when the view instance is resized.	 */	[Event(name="resize", type="flash.events.Event")]		/**	 * Dispatched when the view is renderd.	 */	[Event(name="render", type="flash.events.Event")]		/**	 * Dispatched by the target <code>IDraggingDestination</code> when a dragging object is dropped	 * and the the operations is validated by implementation of <code>IDraggingDestination.acceptsDrop()</code> method.	 */	[Event(name="dragDrop", type="se.raweden.ui.events.UIDragEvent")]	/**	 * Dispatched by the <code>UIDragging</code> when the dragging location moves.	 */	[Event(name="dragUpdate", type="se.raweden.ui.events.UIDragEvent")]	/**	 * Dispatched by the target <code>IDraggingDestination</code> when a dragging operations enters its boundary.	 */	[Event(name="dragEnter", type="se.raweden.ui.events.UIDragEvent")]	/**	 * Dispatched by the target <code>IDraggingDestination</code> when a dragging operations leaves its boundary.	 */	[Event(name="dragExit", type="se.raweden.ui.events.UIDragEvent")]	/**	 * Dispatched by the <code>UIDragging</code> when the dragging ends.	 */	[Event(name="dragEnd", type="se.raweden.ui.events.UIDragEvent")]		/**	 * A <code>UIView</code> Object defines a rectangular area on the screen and the base for managing the content in that	 * area. More sophisticated can be presented by subclassing <code>UIView</code> and implmeneting the necessary drawing n'	 * layout code but also managing user interaction logics.	 * The Core UI framework alos includes a set of standard subclasses which you can use to create your user interface.	 * 	 * <p>Copyright 2011 Raweden. All rights reserved.</p>	 * 	 * @author Raweden	 */	public class UIView extends Sprite implements IDisposable{				/** 		 * Constant that indicates to the <code>render()</code> method that the layout have been invalidated.		 */		public static const NEEDS_LAYOUT:String = "layout";		/** 		 * Constant that indicates to the <code>render()</code> method that the size have been invalidated.		 */		public static const NEEDS_DRAW:String = "draw";				// Instance Invalidation.		private var _invalidates:Object;		private var _invalidated:Boolean = false;		private var _snap:Boolean = false;		// Instance Attributes.		protected var _bounds:Rectangle;		//protected var m_width:Number;		//protected var m_height:Number;		private var _tag:int;		private var _backgroundColor:int = -1;		// Related Views.		protected var _window:UIWindow;				/**		 * Constructor.		 * 		 * @param parent 		 * @param bounds 		 */		public function UIView(parent:DisplayObjectContainer = null,bounds:Rectangle = null){			super();			// initilize the view.			init();			// if the parant is specilazed the component is added to that container.			if(parent){				parent.addChild(this);			}			// if the bounds where specified. the bounds is set for the UIView.			if(bounds){				x = bounds.x;				y = bounds.y;				resize(bounds.width,bounds.height);			}		}				// initlizes the UIView instance.		private function init():void{			_bounds = new Rectangle(0,0,0,0);			_invalidates = new Object();		}				//------------------------------------		// Managing the View Hierarchy		//------------------------------------				/**		 * Indicates the root window of the hierarchy in which this view is contained.		 */		public final function get window():UIWindow{			return this is UIWindow ? this as UIWindow : _window;		}				//------------------------------------		// Getting and Setting View Attributes.		//------------------------------------						/**		 * Determines the background <code>32-bit</code> color of this view.		 * 		 * @default <code>0xFFFFFF</code>		 */		public function set backgroundColor(value:uint):void{			if(value != _backgroundColor){				_backgroundColor = value;				//this.needsDraw();			}		}		// returns the current background color.		public function get backgroundColor():uint{			return _backgroundColor;		}						/**		 * Indicates the bounds of this UIView in it parent cordinate space.		 */		public function set bounds(value:Rectangle):void{			if(value){				this.x = value.x;				this.y = value.y;				resize(value.width,value.height);			}		}		// returns the value of the bounds attribute.		public function get bounds():Rectangle{			return _bounds.clone();		}				/**		 * An integer that can be used to identify the view in your application.		 * 		 * @default <code>0</code> 		 */		public function set tag(value:int):void{			_tag = value;		}		// returns the value of the tag attribute.		public function get tag():int{			return _tag;		}				//------------------------------------		// Deconstruction		//------------------------------------				/**		 * Disposes the UIView instance. Once disposed it should never be used again.		 * 		 * <p>This method should be overriden by super classes for removing references and listners,		 * make sure to always call <code>super.destory()</code>.</p>		 */		public function dispose():void{			this.dispatchEvent(new UIEvent(UIEvent.DISPOSE,false,true));			// removes the viewport from the displaylist.			if(parent){				parent.removeChild(this);			}			this.graphics.clear();			// kills the drawing cycle on this instance.			if(_invalidated){				removeEventListener(Event.EXIT_FRAME,onInvalidation);			}			// removes nulling objects.			_invalidates = null;			_window = null;			_bounds = null;		}				//------------------------------------		// Core UI Drawing Cycle		//------------------------------------				/**		 * Redraws the content in this view immediately.		 * 		 * <p>When overriding this method make sure you call <code>super.render()</code> and don't invoke eather 		 * <code>draw()</code> or <code>layout()</code> in your custom code. by not calling super you may have a		 * big perfomance hit and other Core UI view might also mess up in cource of it.</p>		 */		public function render():void{			var bounds:Rectangle = _bounds.clone();			// Invokes the layout handler.			if(_invalidates.hasOwnProperty("layout") == true){				layout(bounds);				delete _invalidates["layout"];			}			// Invokes the drawing handler.			if(_invalidates.hasOwnProperty("draw") == true){				draw(bounds);				delete _invalidates["draw"];			}			// Invokes custom handlers.			for(var type:String in _invalidates){				if(_invalidates[type] is Function){					_invalidates[type](bounds);				}				delete _invalidates[type];			}			// cancels invalidation if the view where render manualy, by calling render() method.			if(_invalidated){				onInvalidation(null,false);			}			// Determine whether the bounds where changed during render.			if(_bounds.size.equals(bounds.size) == false){				_bounds.width = bounds.width;				_bounds.height = bounds.height;				//m_width = bounds.width;				//m_height = bounds.height;				dispatchEvent(new Event(Event.RESIZE));			}		}				/**		 * 		 * 		 * @param type		 * @param handler		 * 		 */				protected final function needs(type:String,handler:Function = null):void{			if(!_invalidated){				addEventListener(Event.EXIT_FRAME,onInvalidation);				_invalidated = true;			}			if(type != null){				_invalidates[type] = handler != null ? handler : null;			}		}				/**		 * Determine whether the type have been flaged as to be handled on the next drawing cycle.		 * The flags are set by the <code>needs()</code> method. If no argument is provided then		 * the method returns whether any type is set to be handled.		 * 		 * @param type The name of the invalidation type, or null for determine whether any		 * type where set to be handled on the next drawing cycle or when <code>render()</code> is invoked.		 * @return A Boolean value that determine whether the type have been flaged to be handled.		 */		protected final function isInvalidated(type:String = null):Boolean{			if(type != null){				return(_invalidates[type] != null);			}			return _invalidated;		}				/**		 * This method is invoked by the drawing cycle, when the view needs to be redrawn or 		 * when the layout needs to be changed.		 * 		 * @param event  The event triggering this method.		 * @param invoke A Boolean value that determine whether the render() method should be invoked.		 */		private final function onInvalidation(event:Event = null,invoke:Boolean = true):void{			// removes the eventlistner, for the next frame event.			removeEventListener(Event.EXIT_FRAME,onInvalidation);			_invalidated = false;			if(invoke){				render();				}			_invalidates = new Object();		}				//------------------------------------		// Laying out Subviews.		//------------------------------------				/**		 * Calling this method flags that the <code>layout()</code> method needs to be invoked		 * to layout the entire view in the next drawing cycle.		 */		public function needsLayout():void{			//this.needs(UIView.NEEDS_LAYOUT,layout);			needs("layout",layout);		}				/**		 * Laying out subviews inside the <code>rect</code> representing the new bounds of the view.		 * 		 * <p>The Default implementation of this method does nothing.		 * Subclasses can override this method as needed to perform more precise layout of their subviews.		 * You should never call this method directly. This method is by default invoked as the view is resized.</p>		 * 		 * @param rect The bounds representing the position and size of the view.		 */		protected function layout(rect:Rectangle):void{					}				//------------------------------------		// Drawing and Updating the View		//------------------------------------				/**		 * Calling this method flags that the <code>draw()</code> method needs to be invoked 		 * to redraw the entire view in the next drawing cycle.		 */		public function needsDraw():void{			//this.needs(UIView.NEEDS_DRAW,draw);			needs("draw",draw);		}				/**		 * Draws the content of the view within the passed-in rectangle.		 * 		 * <p>The default implementation of this method does nothing.		 * Subclasses that uses <code>flash.display.Graphics</code> (such as Core UI)		 * to draw their view's content to screen should override this methid and 		 * implement their own drawing code there. You do not need to override this		 * if your view displays it's content in other ways. This method should 		 * not be invoked directly use <code>setNeedsDisplay()</code> to invoke this		 * method in the next drawing cycle.</p>		 * 		 * @param rect The bounds representing the position and size of the view.		 */		protected function draw(rect:Rectangle):void{		}				/** 		 * Draws the background layer of the view directly before <code>draw()</code> is invoked.		 * 		 * @param rect The bounds representing the position and size of the view.		 */		protected function drawBackground(rect:Rectangle):void{			this.graphics.clear();			if( _backgroundColor != -1){				this.graphics.beginFill(_backgroundColor,1.0);				this.graphics.drawRect(0,0,rect.width,rect.height);				this.graphics.endFill();			}		}						//------------------------------------		// Managing Gesture Recognizers		//------------------------------------						private var _gestures:Array = null;				public final function addGesture(gesture:Gesture):void{					}				public final function removeGesture(gesture:Gesture):void{					}				public final function gestures():Array{			return _gestures ? _gestures.concat() : null;		}				/**		 * 		 * @param resource			 * @param images			 * @param event	The <code>MouseEvent</code> that triggerd the drag.		 * @return A <code>UIDragging</code> session or null if view fails to initilize a drag.		 */		public final function beginDragging(resource:UIPasteboard,event:MouseEvent):UIDragging{						var session:UIDragging = UIDragging.beginDragging(this,resource,event);						return session;		}								//------------------------------------		// Added functionality.		//------------------------------------						/**		 * Resizes the view by a new width and height, this method ensure that only one resize event		 * is dispatched as the view resizes.		 * 		 * @param width				 * @param height			 */		public function resize(width:int,height:int):void{			// validating input.			width = width < 0 ? 0 : width;			height = height < 0 ? 0 : height;			// setting the actual width and height to be references by the render.			_bounds.width = width;			_bounds.height = height;			// invalidates and indicates size change.			needs("layout",layout);			needs("draw",draw);			this.dispatchEvent(new Event(Event.RESIZE));		}				//------------------------------------		// Override the default DisplayObject properties.		//------------------------------------				/**		 * @inheritDoc		 */		public override function set width(value:Number):void{			value = int(value);			value = value < 0 ? 0 : value;			// validating changes to the render, is no need to redraw if the value is the same as before.			if(value == _bounds.width)return;			_bounds.width = value;			needs("layout",layout);			needs("draw",draw);			this.dispatchEvent(new Event(Event.RESIZE));		}		// returns the value of the width attribute.		public override function get width():Number{			return _bounds.width;		}				/**		 * @inheritDoc		 */		public override function set height(value:Number):void{			value = int(value);			value = value < 0 ? 0 : value;			// validating changes to the render, is no need to redraw if the value is the same as before.			if(value == _bounds.height)return;			_bounds.height = value;			needs("layout",layout);			needs("draw",draw);			this.dispatchEvent(new Event(Event.RESIZE));		}		// returns the value of the height attribute.		public override function get height():Number{			return _bounds.height;		}				/**		 * @inheritDoc		 */		override public function set x(value:Number):void{			super.x = value;		}				/**		 * @inheritDoc		 */		override public function set y(value:Number):void{			super.y = value;		}				//------------------------------------		// Overriding the default hieraki of the displaylist to reference the window instances.		//------------------------------------				/**		 * @inheritDoc		 */				override public function addChild(child:DisplayObject):DisplayObject{			child = super.addChild(child);			// manages the hieraky of windows.			var view:UIView = child as UIView;			if(view)				view.attacthWindow(window);			// returns the child.			return child;		}				/**		 * @inheritDoc		 */				override public function addChildAt(child:DisplayObject, index:int):DisplayObject{			child = super.addChildAt(child,index);			// manages the hieraky of windows.			var view:UIView = child as UIView;			if(view)				view.attacthWindow(window);			// returns the child.			return child;		}				/**		 * @inheritDoc		 */				override public function removeChild(child:DisplayObject):DisplayObject{			child = super.removeChild(child);			// manages the hieraky of windows.			var view:UIView = child as UIView;			if(view)				view.attacthWindow(null);			// returns the child.			return child;		}				/**		 * @inheritDoc		 */				override public function removeChildAt(index:int):DisplayObject{			var child:DisplayObject = super.removeChildAt(index);			// manages the hieraky of windows.			var view:UIView = child as UIView;			if(view)				view.attacthWindow(null);			// returns the child.			return child;		}				// adding and removeing the view from a hieraky represented by UIWindow(s).		private final function attacthWindow(window:UIWindow):void{			var view:UIView;			var len:int = this.numChildren;			for(var i:int = 0;i<len;i++){				view = this.getChildAt(i) as UIView;				if(view)					view.attacthWindow(window);			}			_window = window;		}					}}