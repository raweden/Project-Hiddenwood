////	UIView.as//	Core UI Framework////	Created by Raweden on 2011-08-05//	Copyright 2011 Raweden. Some rights reserved.//package se.raweden.ui.view{		import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Point;	import flash.geom.Rectangle;		import se.raweden.core.core;	import se.raweden.ui.desktop.UIDragging;	import se.raweden.ui.desktop.UIPasteboard;	import se.raweden.utils.IDisposable;		/**	 * A <code>UIView</code> Object defines a rectangular area on the screen and the base for managing the content in that	 * area. More sophisticated can be presented by subclassing <code>UIView</code> and implmeneting the necessary drawing n'	 * layout code but also managing user interaction logics.	 * The Core UI framework alos includes a set of standard subclasses which you can use to create your user interface.	 * 	 * @copyright Copyright 2011 Raweden. All rights reserved.	 * @author Raweden	 */	public class UIView extends Sprite implements IDisposable{				use namespace core;				/** 		 * Constant that indicates to the <code>render()</code> method that the layout have been invalidated.		 */		public static const INVALIDATE_LAYOUT:String = "layout";		/** 		 * Constant that indicates to the <code>render()</code> method that the size have been invalidated.		 */		public static const INVALIDATE_DISPLAY:String = "display";				// instance core variables.		protected var m_window:UIWindow;		protected var m_bounds:Rectangle;		protected var m_width:Number;		protected var m_height:Number;		// instance private variables.				private var m_invalidates:Object;		private var m_invalidated:Boolean = false;		private var m_tag:int;		// background properties.		private var m_backgroundColor:int = -1;				/**		 * 		 */		public function UIView(parent:DisplayObjectContainer = null,frame:Rectangle = null){			super();			// initilize the view.			init();			// if the parant is specilazed the component is added to that container.			if(parent){				parent.addChild(this);			}			// if the bounds where specified. the bounds is set for the UIView.			if(frame){				x = frame.x;				y = frame.y;				resize(frame.width,frame.height);			}		}				// initlizes the UIView instance.		private function init():void{			m_bounds = new Rectangle();			m_invalidates = new Object();		}				//------------------------------------		// Managing the View Hierarchy		//------------------------------------				/**		 * Indicates the root window of this view hierarchy.		 */		public final function get window():UIWindow{			return this is UIWindow ? this as UIWindow : m_window;		}				/**		 * Removes this view instance from it superview.		 */		public function removeFromParent():void{			if(this.parent){				this.parent.removeChild(this);			}		}								//------------------------------------		// Getting and Setting View Attributes.		//------------------------------------						/**		 * Determines the background <code>32-bit</code> color of this view.		 * 		 * @default <code>0xFFFFFF</code>		 */		public function set backgroundColor(value:uint):void{			if(value != m_backgroundColor){				m_backgroundColor = value;				this.setNeedsDisplay();			}		}		// returns the current background color.		public function get backgroundColor():uint{			return m_backgroundColor;		}				/**		 * Indicates the bounds of this UIView in it own cordinate space.		 * 		 * <p>The bounds are updated if changed on each render cycle.</p>		 */		public function get bounds():Rectangle{			return m_bounds.clone();		}				/**		 * Indicates the bounds of this UIView in it parent cordinate space.		 */		public function set frame(value:Rectangle):void{			if(value){				this.x = value.x;				this.y = value.y;				resize(value.width,value.height);			}		}		// returns a copy of the current frame.		public function get frame():Rectangle{			return this.parent ? this.getBounds(this.parent) : null;		}				/**		 * An integer that can be used to identify the view in your application.		 * 		 * @default <code>0</code> 		 */		public function set tag(value:int):void{			m_tag = value;		}		// returns the tag of this view.		public function get tag():int{			return m_tag;		}				//------------------------------------		// Deconstruction		//------------------------------------				/**		 * Disposes the UIView instance. Once disposed it should never be used again.		 * 		 * <p>This method should be overriden by super classes for removing references and listners,		 * make sure to always call <code>super.destory()</code>.</p>		 */		public function dispose():void{			this.dispatchEvent(new Event("dispose"));			// removes the viewport from the displaylist.			this.removeFromParent();			this.graphics.clear();			// kills the drawing cycle on this instance.			if(m_invalidated){				removeEventListener(Event.EXIT_FRAME,onInvalidation);			}			// removes nulling objects.			m_invalidates = null;			m_window = null;			m_bounds = null;		}				//------------------------------------		// Core UI Drawing Cycle		//------------------------------------				/**		 * Redraws the content in this view immediately.		 * 		 * <p>When overriding this method make sure you call <code>super.render()</code> and don't invoke eather 		 * <code>draw()</code> or <code>layout()</code> in your custom code. by not calling super you may have a		 * big perfomance hit and other Core UI view might also mess up in cource of it.</p>		 */		public function render():void{			// refreshing the frame of the view.			m_bounds.width = m_width;			m_bounds.height = m_height;			var rect:Rectangle = m_bounds.clone();			// invokes the layout method.			if(isInvalidated(UIView.INVALIDATE_LAYOUT)){				layout(rect);				this.dispatchEvent(new Event("layout"));			}			// invokes the drawing method.			if(isInvalidated(UIView.INVALIDATE_DISPLAY)){				drawBackground(rect);				draw(rect);				this.dispatchEvent(new Event("draw"));			}			// calls the onInvalidation if the view's render cycle where triggerd before the actual render cycle.			if(m_invalidated)				onInvalidation(null,false);					this.dispatchEvent(new Event(Event.RENDER));			// Complare the renderd bounds against input bounds.			if(!m_bounds.size.equals(rect.size)){				m_width = rect.width;				m_height = rect.height;				this.dispatchEvent(new Event(Event.RESIZE));			}			// temporary developer testing.			//trace("render "+this.toString()+" tag: "+m_tag+" @"+m_width+"x"+m_height);		}				/**		 * Invalidates the view, this forces the view to be redrawn on the next frame.		 * 		 * <p>This method can be invoked with a type argument to indicate to the render method		 * that the properity needs to be re-rendered. in a <code>render()</code> <code>override</code> 		 * you can check if a Property where invalidated with a code simular to this <code>invalidated("example")</code></p>		 * @param type The reference to be invoked with the <code>render()</code> method.		 */		protected final function invalidate(type:String = null):void{			if(!m_invalidated){				addEventListener(Event.EXIT_FRAME,onInvalidation);				m_invalidated = true;			}			if(type != null){				m_invalidates[type] = true;			}		}				/**		 * Determine if any property have been invalidated or if a certain property is invalidated by		 * passing the property name as the <code>type</code> argument.		 * 		 * @param type The name of the property or null for determine if any property is invalidated.		 */		protected final function isInvalidated(type:String = null):Boolean{			if(type != null){				return(m_invalidates[type] != null);			}			return(m_invalidated);		}				/**		 * This method is invoked by the Core UI in the drawing cycle if any property have been invalidated.		 * <p><h1><b>Never invoke this method!</h1></b></p>		 */		protected final function onInvalidation(e:Event = null,call:Boolean = true):void{			// removes the eventlistner, for the next frame event.			removeEventListener(Event.EXIT_FRAME,onInvalidation);			m_invalidated = false;			if(call){				render();				}			m_invalidates = new Object();		}				/**		 * Returns a <code>Object</code> containing the properties that needs to be updated		 * in the next drawing cycle or when the <code>render()</code> method is invoked.		 */		protected function get invalidates():Object{			return(m_invalidates)		}				//------------------------------------		// Laying out Subviews.		//------------------------------------				/**		 * Calling this method flags that the <code>layout()</code> method needs to be invoked		 * to layout the entire view in the next drawing cycle.		 */		public function setNeedsLayout():void{			this.invalidate(UIView.INVALIDATE_LAYOUT);		}				/**		 * Laying out subviews inside the <code>rect</code> representing the new bounds of the view.		 * 		 * <p>The Default implementation of this method does nothing.		 * Subclasses can override this method as needed to perform more precise layout of their subviews.		 * You should never call this method directly. This method is by default invoked as the view is resized.</p>		 * 		 * @param rect The bounds representing the position and size of the view.		 */		protected function layout(rect:Rectangle):void{					}				//------------------------------------		// Drawing and Updating the View		//------------------------------------				/**		 * Calling this method flags that the <code>draw()</code> method needs to be invoked 		 * to redraw the entire view in the next drawing cycle.		 */		public function setNeedsDisplay():void{			this.invalidate(UIView.INVALIDATE_DISPLAY);		}				/**		 * Draws the content of the view within the passed-in rectangle.		 * 		 * <p>The default implementation of this method does nothing.		 * Subclasses that uses <code>flash.display.Graphics</code> (such as Core UI)		 * to draw their view's content to screen should override this methid and 		 * implement their own drawing code there. You do not need to override this		 * if your view displays it's content in other ways. This method should 		 * not be invoked directly use <code>setNeedsDisplay()</code> to invoke this		 * method in the next drawing cycle.</p>		 * 		 * @param rect The bounds representing the position and size of the view.		 */		protected function draw(rect:Rectangle):void{		}				/** 		 * Draws the background layer of the view directly before <code>draw()</code> is invoked.		 * 		 * @param rect The bounds representing the position and size of the view.		 */		protected function drawBackground(rect:Rectangle):void{			this.graphics.clear();			if( m_backgroundColor != -1){				this.graphics.beginFill(m_backgroundColor,1.0);				this.graphics.drawRect(0,0,rect.width,rect.height);				this.graphics.endFill();			}		}				//------------------------------------		// Dragging and Dropping data.		//------------------------------------				/**		 * 		 * @param pasteboard		 * @param images		 * @param event The <code>MouseEvent</code> that triggerd the drag.		 * @return A <code>UIDragging</code> session or null if view fails to initilize a drag.		 */		public final function beginDragging(pasteboard:UIPasteboard,images:Array,event:MouseEvent):UIDragging{			var session:UIDragging = new UIDragging(pasteboard,images);			session.draggingOffset = new Point(this.mouseX,this.mouseY);			UIDragging.beginDragging(session,this,images,event);			return session;		}				//------------------------------------		// Added functionality.		//------------------------------------				/**		 * Resizes the view by a new width and height, this method ensure that only one resize event		 * is dispatched as the view resizes.		 */		public function resize(width:int,height:int):void{			// validating input.			width = width < 0 ? 0 : width;			height = height < 0 ? 0 : height;			// setting the actual width and height to be references by the render.			m_width = width;			m_height = height;			// invalidates and indicates size change.			invalidate(UIView.INVALIDATE_DISPLAY);			invalidate(UIView.INVALIDATE_LAYOUT);			this.dispatchEvent(new Event(Event.RESIZE));		}				//------------------------------------		// Override the default DisplayObject properties.		//------------------------------------				/**		 * @inheitDoc		 */		public override function set width(value:Number):void{			value = int(value);			value = value < 0 ? 0 : value;			// validating changes to the render, is no need to redraw if the value is the same as before.			if(value == m_width)return;			m_width = value;			invalidate(UIView.INVALIDATE_DISPLAY);			invalidate(UIView.INVALIDATE_LAYOUT);			this.dispatchEvent(new Event(Event.RESIZE));		}		// returns the current widht of this component instance.		public override function get width():Number{			return(m_width);		}				/**		 * @inheitDoc		 */		public override function set height(value:Number):void{			value = int(value);			value = value < 0 ? 0 : value;			// validating changes to the render, is no need to redraw if the value is the same as before.			if(value == m_height)return;			m_height = value;			invalidate(UIView.INVALIDATE_DISPLAY);			invalidate(UIView.INVALIDATE_LAYOUT);			this.dispatchEvent(new Event(Event.RESIZE));		}		// returns the current height of this component instance.		public override function get height():Number{			return(m_height);		}				//------------------------------------		// Overriding the default hieraki of the displaylist to reference the window instances.		//------------------------------------				/**		 * @inheitDoc		 */				override public function addChild(child:DisplayObject):DisplayObject{			child = super.addChild(child);			// manages the hieraky of windows.			var view:UIView = child as UIView;			if(view)				view.attacthWindow(window);			// returns the child.			return child;		}				/**		 * @inheitDoc		 */				override public function addChildAt(child:DisplayObject, index:int):DisplayObject{			child = super.addChildAt(child,index);			// manages the hieraky of windows.			var view:UIView = child as UIView;			if(view)				view.attacthWindow(window);			// returns the child.			return child;		}				/**		 * @inheitDoc		 */				override public function removeChild(child:DisplayObject):DisplayObject{			child = super.removeChild(child);			// manages the hieraky of windows.			var view:UIView = child as UIView;			if(view)				view.attacthWindow(null);			// returns the child.			return child;		}				/**		 * @inheitDoc		 */				override public function removeChildAt(index:int):DisplayObject{			var child:DisplayObject = super.removeChildAt(index);			// manages the hieraky of windows.			var view:UIView = child as UIView;			if(view)				view.attacthWindow(null);			// returns the child.			return child;		}				// adding and removeing the view from a hieraky represented by UIWindow(s).		private final function attacthWindow(window:UIWindow):void{			var view:UIView;			var len:int = this.numChildren;			for(var i:int = 0;i<len;i++){				view = this.getChildAt(i) as UIView;				if(view)					view.attacthWindow(window);			}			m_window = window;		}					}}