package se.raweden.ui.view{	import flash.display.DisplayObjectContainer;	import flash.display.Sprite;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.text.AntiAliasType;	import flash.text.GridFitType;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.text.TextFieldType;	import flash.text.TextFormat;
		/**	 * A <code>UIText</code> component 	 * 	 * <p>Copyright 2011 Raweden. All rights reserved.</p>	 * 	 * @author Raweden	 */	public class UITextView extends UIScrollView{						//		// TODO: use the flash text engine to render the text. check this: http://www.developria.com/2009/03/flash-text-engine.html		//						// attributes.		private var _displayAsHtml:Boolean = false;		// related views.		private var _content:Sprite;		private var _render:TextField;				public function UITextView(parent:DisplayObjectContainer = null){			super(parent);			// initilizes the text view.			addChildren();			init();		}				/**		 * Creates and adds related view instances.		 */		private function addChildren():void{			_render = new TextField();			_render.defaultTextFormat = new TextFormat("Helvetica",13);			_render.embedFonts = false;			_render.autoSize = TextFieldAutoSize.LEFT;			_render.gridFitType = GridFitType.SUBPIXEL;			_render.antiAliasType = AntiAliasType.ADVANCED;			_render.x = 10;			_render.y = 4;			_content = new Sprite();			_content.addChild(_render);			super.content = _content;		}				/**		 * Instance initilization.		 */		private function init():void{			this.editable = false;			this.wordWrap = true;			// setting the default size.			resize(640,360);		}						//------------------------------------ 		//	Configuring the UIText view.		//------------------------------------ 						/**		 * Determines if the Text component is editable.		 * 		 * @default <code>false</code>		 */		public function set editable(value:Boolean):void{			_render.selectable = value;			_render.mouseEnabled = value;			_render.type = value ? TextFieldType.INPUT : TextFieldType.DYNAMIC;		}		// returns the value of the editable attribute.		public function get editable():Boolean{			return(_render.type == TextFieldType.INPUT);		}				/**		 * Specifies the text of this UIText view.		 */		public function set text(value:String):void{			if(_displayAsHtml){				_render.htmlText = value;			}else{				_render.text = value;			}					needs("layout",layout);			needs("draw",draw);		}		// returns the value of the text attribute.		public function get text():String{			return _displayAsHtml ? _render.htmlText : _render.text;		}				/**		 * A Boolean value that determine whether the string of the text properity should be renderd as html.		 * 		 * @default <code>false</code>		 */		public function set displayAsHtml(value:Boolean):void{			if(value !=	_displayAsHtml){				if(value){					_render.htmlText = _render.text;				}else{					_render.text = _render.htmlText;				}				_displayAsHtml = value;					// display needs to update as the size may change.				needs("layout",layout);				needs("draw",draw);			}		}		// returns the value of the displayAsHtml attribute.		public function get displayAsHtml():Boolean{			return _displayAsHtml;		}				/**		 * A Boolean value that determine whether the 		 * 		 * @default <code>false</code>		 */		public function set wordWrap(value:Boolean):void{			_render.wordWrap = value;			needs("layout",layout);		}		// returns the value of the wordWrap attribute.		public function get wordWrap():Boolean{			return(_render.wordWrap);		}				/**		 * A Boolean value that determine whether the 		 * 		 * @default <code>true</code>		 */		public function set selectable(value:Boolean):void{			_render.selectable = value;			needs("layout",layout);		}		// returns the value of the selectable attribute.		public function get selectable():Boolean{			return(_render.selectable);		}				public function setTextFormat(format:TextFormat,beginIndex:int = -1,endIndex:int = -1):void{			_render.setTextFormat(format,beginIndex,endIndex);			needs("layout",layout);		}				/**		 * 		 */		public function set defaultTextFormat(value:TextFormat):void{			_render.defaultTextFormat = value;		}		// returns the value of the defaultTextFormat attribute.		public function get defaultTextFormat():TextFormat{			return _render.defaultTextFormat;		}						// Getting Information about the Text.				/**		 * Returns a rectangle that is the bounding box of the character.		 */		public function getCharBoundaries(charIndex:int):Rectangle{			return null;		}				/**		 * Returns the zero-based index value of the character at the point specified by the x and y parameters.		 */		public function getCharIndexAtPoint(x:Number, y:Number):int{			return -1;		}				/**		 * Given a character index, returns the index of the first character in the same paragraph.		 */		public function getFirstCharInParagraph(charIndex:int):int{			return -1;		}				/**		 * Returns the zero-based index value of the line at the point specified by the x and y parameters.		 */		public function getLineIndexAtPoint(x:Number, y:Number):int{			return -1;			}				/**		 * Returns the zero-based index value of the line containing the character specified by the charIndex parameter.		 */		public function getLineIndexOfChar(charIndex:int):int{			return -1;		}				/**		 * Returns the number of characters in a specific text line.		 */		public function getLineLength(lineIndex:int):int{			return -1;		}				/**		 * Returns the character index of the first character in the line that the lineIndex parameter specifies.		 */		public function getLineOffset(lineIndex:int):int{			return -1;		}				/**		 * Returns the text of the line specified by the lineIndex parameter.		 */		public function getLineText(lineIndex:int):String{			return null;		}				/**		 * Given a character index, returns the length of the paragraph containing the given character.		 */		public function getParagraphLength(charIndex:int):int{			return -1;		}						// Managing Text Selection.						/**		 * Sets as selected the text designated by the index values of the first and last characters, 		 * which are specified with the beginIndex and endIndex parameters.		 * 		 * @param beginIndex		 * @param endIndex		 */		public function setSelection(beginIndex:int,endIndex:int):void{			return _render.setSelection(beginIndex,endIndex);		}				/**		 * The zero-based character index value of the first character in the current selection.		 */		public function get selectionBeginIndex():int{			return _render.selectionBeginIndex;		}						/**		 * The zero-based character index value of the last character in the current selection.		 */		public function get selectionEndIndex():int{			return _render.selectionEndIndex;		}						// Managing Text.						/**		 * Appends the string specified by the newText parameter to the end of the text of the text field. 		 */		public function appendText(newText:String):void{			_render.appendText(newText);						// needs to refresh display as the bounds may have changed.			needs("layout",layout);			needs("draw",draw);		}				/**		 * Replaces the range of characters that the beginIndex and endIndex parameters specify 		 * with the contents of the newText parameter.		 */		public function replaceText(beginIndex:int,endIndex:int,newText:String):void{			_render.replaceText(beginIndex,endIndex,newText);						// needs to refresh display as the bounds may have changed.			needs("layout",layout);			needs("draw",draw);		}						//------------------------------------		// Updating Content Displayed.		//------------------------------------						/**		 * @inheritDoc		 */		override protected function draw(rect:Rectangle):void{			var w:int = rect.width;			var h:int = rect.height;			// drawing the background color for the main scrollview.			this.graphics.clear();			this.graphics.beginFill(0x000000,0.05);			this.graphics.drawRect(0,0,w,h);			this.graphics.endFill();			// determine the maximum height/width.			w = Math.max(w,_render.width+24);			h = Math.max(h,_render.height+8);			// drawing background color behind the text.			var color:uint = backgroundColor;			_content.graphics.clear();			_content.graphics.beginFill(color);			_content.graphics.drawRect(0,0,w,h);			_content.graphics.endFill();		}				/**		 * @inheritDoc		 */		override protected function layout(rect:Rectangle):void{			if(this.wordWrap)				_render.width = rect.width-24;			super.layout(rect);		}				//------------------------------------		// Deconstruction		//------------------------------------				/**		 * @inheritDoc		 */		override public function dispose():void{			// destoying the super implemenation.			super.dispose();		}		}}