package se.raweden.ui.view{		import flash.display.DisplayObjectContainer;	import flash.display.Shape;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Point;	import flash.geom.Rectangle;		import se.raweden.motion.Tween;	import se.raweden.ui.events.UIScrollEvent;
		/**	 * Dispatched when the content of the scroll view scrolls.	 */	[Event(name="scroll", type="flash.events.Event")]		/**	 * A <code>UIScrollView</code> component enables users to scroll within content	 * that is larger than the actual shown portion of the view. It enables users 	 * to scroll by using the mouse or the swipe gesture on a touch device and to	 * zoom back and forth using the pinching gestures. 	 * 	 * <p>Copyright 2011 Raweden. All rights reserved.</p>	 * 	 * @author Raweden	 */	public class UIScrollView extends UIView{						//		// TODO: fix dragMove section where dragging is fixed to its bounds, its doesn't work when content is less than view.		// TODO: add zooming capibitly, using rectangular area to scale the content view.		// TODO: remove glitcy behaivor on buncing.		// TODO: add paging logics.		// TODO: add logics based on input device.		// TODO: always show overlay scrollers on hover on pc.		// TODO: add support with magic-mouse and trackpad on mac.		//		// TODO: disable mouseChildren on the content when scrolling.		// TODO: stop dragging as mouses leaves stage.		//				// Constant values.		private static const THRESHOLD:Number = 0.24;			// The smallest allowed velocity threshold.		private static const BOUNCING_SPRINGESS:Number = 0.45;	// The springess of the bouncing behavior.		private static const THROW_DECAY:Number = 0.92;				// Content related variabels.		private var _content:DisplayObjectContainer;		private var _scrollRect:Rectangle = new Rectangle(0,0);		private var m_mask:Shape;		// Scrollview general behvavior.		private var _scrollEnabled:Boolean = true;		private var _pagingEnabled:Boolean = true;		// Bouncing and scrolling.		private var _offset:Point = new Point();		private var dragPoint:Point = new Point();		private var vy:Number = 0;		private var vx:Number = 0;		// Bouncing behvaior.		private var _alwaysBounceHorizontal:Boolean = false;		private var _alwaysBounceVertical:Boolean = false;		private var _bounces:Boolean = true;		private var _dragging:Boolean = false;		private var _decelerating:Boolean = false;		// this boolean also indicates if the enterFrame listners is added.		// Scroll Indicators and related properties.		private var _verticalIndicator:UIScroller;		private var _horizontalIndicator:UIScroller;		private var _alwaysShowIndicators:Boolean = false;		private var _showVerticalIndicator:Boolean = true;		private var _showHorizontalIndicator:Boolean = true;		// Zooming and panning 		private var _zoomScale:Number = 1.0;		private var _maximumZoomScale:Number = 1.0;		private var _minimumZoomScale:Number = 1.0;		private var _zooming:Boolean = false;						/**		 * 		 */		public function UIScrollView(parent:DisplayObjectContainer = null, content:UIView = null){			super(parent);			// initlizes the scroll view.			addChildren();			init();			// specifies the content			this.content = content;		}				// adds child component and display objects to the scrollview.		private function addChildren():void{			m_mask = new Shape();			m_mask.graphics.beginFill(0x000000);			m_mask.graphics.drawRect(0,0,100,100);			m_mask.graphics.endFill();			this.addChild(m_mask);			this.mask = m_mask;		}				// initilizes the scroll view.		private function init():void{			this.addEventListener(UIScrollEvent.SCROLL,scrollWheelMoved);		}				//------------------------------------		// Managing Scrolling		//------------------------------------				/**		 * A <code>Boolean</code> value that determines if scrolling is enabled in the scroll view.		 * 		 * @default <code>true</code>		 */		public function set scrollEnabled(value:Boolean):void{			_scrollEnabled = value;		}		// returns the value of the scrollEnabled attribute.		public function get scrollEnabled():Boolean{			return _scrollEnabled;		}				/**		 * A <code>Boolean</code> valie tath determines whether paging is enabled for the scroll view.		 * 		 * <p>If this value is set to <code>true</code>, the scroll view stops on the nearest 		 * multiple if the scroll view's bounds when the user scrolls.</p>		 * 		 * @default <code>false</code>		 */		public function set pagingEnabled(value:Boolean):void{			if(value != this._pagingEnabled){				if(_content){					if(value){						_content.addEventListener(MouseEvent.MOUSE_DOWN,dragStart);					}else{						_content.removeEventListener(MouseEvent.MOUSE_DOWN,dragStart);					}				}				_pagingEnabled = value;			}		}		// // returns the value of the pageingEnabled attribute.		public function get pagingEnabled():Boolean{			return _pagingEnabled;		}				/**		 * A <code>Boolean</code> value that controls whether the scroll view bounces past the edge of the content and back again.		 *  		 * @default <code>true</code>		 */		public function set bounces(value:Boolean):void{			_bounces = value;		}		// returns the value of the bounces attribute.		public function get bounces():Boolean{			return _bounces;		}						/**		 * A <code>Boolean</code> value that determines whether bouncing allways occurs when vertical scrolling reaches the end of the content view.		 * 		 * @default <code>false</code>		 */		public function set alwaysBounceVertical(value:Boolean):void{			_alwaysBounceVertical = value;		}		// // returns the value of the alwaysBounceVertical attribute.		public function get alwaysBounceVertical():Boolean{			return _alwaysBounceVertical;		}				/**		 * A <code>Boolean</code> value that determines whether bouncing allways occurs when horizontal scrolling reaches the end of the content view.		 * 		 * @default <code>false</code>		 */		public function set alwaysBounceHorizontal(value:Boolean):void{			if(value != _alwaysBounceHorizontal){				_alwaysBounceHorizontal = value;			}		}		// returns the value of the alwaysBounceHorizontal attribute.		public function get alwaysBounceHorizontal():Boolean{			return _alwaysBounceHorizontal;		}					/**		 * A <code>Boolean</code> value that indicates whether the user has begun scrolling the content.		 */		public function get dragging():Boolean{			return _dragging;		}				/**		 * A <code>Boolean</code> value that indicates whether the scroll view is currently decelerating after scrolling the content.		 */		public function get decelerating():Boolean{			return _decelerating;		}				//------------------------------------		// Managing Scroll Indicators.		//------------------------------------				/**		 * Specifies the horizontal scroll offset in pixels.		 */		public function set scrollX(value:Number):void{			_content.x = -value;			_scrollRect.x = value;			// not implemeneted.		}		// returns the value of the scrollX attribute.		public function get scrollX():Number{			return _scrollRect.x;		}				/**		 * Specifies the vertical scroll offset in pixels.		 */		public function set scrollY(value:Number):void{			_content.y = -value;			_scrollRect.y = value;			// not implemented.		}		// returns the value of the scrollY attribute.		public function get scrollY():Number{			return _scrollRect.y;		}				//------------------------------------		// Managing Scroll indicators.		//------------------------------------				/**		 * 		 */		public function set alwaysShowIndicators(value:Boolean):void{			if(_alwaysShowIndicators != value){				// 				if(_horizontalIndicator){					_horizontalIndicator.alwaysVisible = value;				}				//				if(_verticalIndicator){					_verticalIndicator.alwaysVisible = value;				}				_alwaysShowIndicators = value;			}		}		// returns the value of the alwaysShowIndicators attribute.		public function get alwaysShowIndicators():Boolean{			return _alwaysShowIndicators;		}				/**		 * 		 */		public function set showHorizontalIndicator(value:Boolean):void{			if(value != _showHorizontalIndicator){				if(_horizontalIndicator){					_verticalIndicator.alwaysVisible = value;				}				_showHorizontalIndicator = value;			}		}		// returns the value of the showHorizontalIndicator attribute.		public function get showHorizontalIndicator():Boolean{			return _showHorizontalIndicator;		}				/**		 * 		 */		public function set showVerticalIndicator(value:Boolean):void{			if(value != _showVerticalIndicator){				if(_verticalIndicator){					_verticalIndicator.alwaysVisible = value;				}				_showVerticalIndicator = value;			}		}		// returns the value of the showVerticalIndicator attribute.		public function get showVerticalIndicator():Boolean{			return _showVerticalIndicator;		}				/**		 * Displays the scrollers for a monent to indicate to the user that there is more to see.		 */		public function flashIndicators():void{			if(_verticalIndicator){				_verticalIndicator.flash();			}			if(_horizontalIndicator){				_horizontalIndicator.flash();			}		}				/**		 * 		 */		public function get verticalIndicator():UIScroller{			if(!_verticalIndicator){				_verticalIndicator = new UIScroller(this);				_verticalIndicator.y = 2;				_verticalIndicator.addEventListener(Event.SCROLL,onVScroll);				needs("layout",layout);			}			return _verticalIndicator;		}				/**		 * 		 */		public function get horizontalIndicator():UIScroller{			if(!_horizontalIndicator){				_horizontalIndicator = new UIScroller(this);				_horizontalIndicator.direction = UIScroller.DIRECTION_HORIZONTAL;				_horizontalIndicator.x = 2;				_horizontalIndicator.addEventListener(Event.SCROLL,onHScroll);				needs("layout",layout);			}			return _horizontalIndicator;		}				//------------------------------------		// Setting and Getting Content View.		//------------------------------------				/**		 * 		 */		public function set content(value:DisplayObjectContainer):void{			if(_content){				_content.removeEventListener(Event.RESIZE,onContentResize);				// removing panning listener, if enabled.				if(_pagingEnabled){					_content.removeEventListener(MouseEvent.MOUSE_DOWN,dragStart);					}				// removing the content from the scrollview.				if(this.contains(_content)){					this.removeChild(_content);				}			}			_content = value;			if(_content){				_content.addEventListener(Event.RESIZE,onContentResize);				// adding panning listener, if enabled.				if(_pagingEnabled){					_content.addEventListener(MouseEvent.MOUSE_DOWN,dragStart);					}				this.addChildAt(_content,0);			}			// refrehing the layout.			needs("layout",layout);		}		// returns the value of the content attribute.		public function get content():DisplayObjectContainer{			return _content;		}						/**		 * Responding the the resize of the content view.		 */		private function onContentResize(e:Event):void{			this.needsLayout();		}				//------------------------------------		// Responding to user Interaction and Dragging and Throwing the content view.		//------------------------------------					/**		 * Triggerd when as the user begins dragging the content view.		 */		private function dragStart(e:MouseEvent):void{			_dragging = true;			stage.addEventListener(MouseEvent.MOUSE_UP,dragStop);			stage.addEventListener(Event.MOUSE_LEAVE,dragStop);			// Register for enter frame listener to drag the content and animate the scrolling and bounces.			if(!_decelerating){				this.addEventListener(Event.ENTER_FRAME,dragMove);				//trace("did start scroll animation");			}						if(_showVerticalIndicator){				verticalIndicator.visible = true;			}						if(_showHorizontalIndicator){				horizontalIndicator.visible = true;			}						// TODO: carculate mouse offset when contnet is scaled, current impl don't works.						// Getting Local offset relative to the content.			_offset.x = _content.mouseX;			_offset.y = _content.mouseY;			//trace("offset:",_offset);			dragPoint.x = this.mouseX;			dragPoint.y = this.mouseY;			vy = 0;			vx = 0;		}					/**		 * Triggerd as the user is dragging or throwing the content view.		 */		private function dragMove(e:Event):void{			var x:Number;			var y:Number;			var max_x:Number = canScrollHorizontal ? -Math.abs(_content.width-width) : 0;			var max_y:Number = canScrollVertical ? -Math.abs(_content.height-height) : 0;			// 			if(_dragging){				// getting where the content should be draged.				x = this.mouseX-_offset.x;				y = this.mouseY-_offset.y;				// getting the velocity.				vx = this.mouseX-dragPoint.x;				vy = this.mouseY-dragPoint.y;				// setting reference.				dragPoint.x = this.mouseX;				dragPoint.y = this.mouseY;				// constrains the paning of the content based up on setup - Horizontaly.				if(!_alwaysBounceHorizontal){					if(x > 0){						vx = 0;						x = 0;					}else if(x < max_x){						vx = 0;						x = max_x;					}						}				// Constrains the paning of the content based up on setup - Verticaly.				if(!_alwaysBounceVertical){					if(y > 0){						vy = 0;						y = 0;					}else if(y < max_y){						vy = 0;						y = max_y;					}						}			}else{				var bx:Number = 0;				var by:Number = 0;								x = _content.x;				y = _content.y;				// Constrains the horizontal bounds to the content bounds.				if(_bounces){					// determine the horinzontal bounce.					if(x > 0 || max_x > 0){						bx = -x * BOUNCING_SPRINGESS;					}else if(x < max_x){						bx = (max_x - x) * BOUNCING_SPRINGESS;					}							// determine the vertical bounce.					if(y > 0 || max_y > 0){						by = -y * BOUNCING_SPRINGESS;					}else if(y < max_y){						by = (max_y - y) * BOUNCING_SPRINGESS;					}							// determine content final offset.					x = x+vx+bx;					y = y+vy+by;				}else{					// Constrains the horizontal bounds to the content bounds.					if(x > 0){						vx = 0;						x = 0;					}else if(x < max_x){						vx = 0;						x = max_x;					}					// Constrains the vertical bounds to the content bounds.					if(y > 0){						vy = 0;						y = 0;					}else if(y < max_y){						vy = 0;						y = max_y;					}						// determine content final offset.					x = x+vx;					y = y+vy;				}				// decay of velocity (friction).				vy *= THROW_DECAY;				vx *= THROW_DECAY;				// determine if velocity is enough to animate the content offset.				var tx:Boolean = Math.abs(vx) < THRESHOLD;				var ty:Boolean = Math.abs(vy) < THRESHOLD;				vx = tx ? 0 : vx;				vy = ty ? 0 : vy;				tx = tx && Math.abs(bx) == 0;				ty = ty && Math.abs(by) == 0;				// determine of both values is below the threshold.				if(tx && ty){					this.removeEventListener(Event.ENTER_FRAME,dragMove);					_decelerating = false;				}			}			var a:int;			// Updating vertical indicator if added.			if(_verticalIndicator){				_verticalIndicator.procent = y/max_y;				trace("setting v-procent:", y/max_y);				if(y > 0){					a = y;				}else if(y < max_y){					a = Math.abs(y-max_y);				}				_verticalIndicator.ratio = height/(a+_content.height);			}			// Updating horizontal indicator if added.			if(_horizontalIndicator){				_horizontalIndicator.procent = x/max_x;				trace("setting h-procent:", y/max_y);				a = 0;				if(x > 0){					a = x;				}else if(x < max_x){					a = Math.abs(x-max_x);				}				_horizontalIndicator.ratio = width/(a+_content.width);			}			// setting the final positon of the content.			this.scrollX = -x;			this.scrollY = -y;			//log("content is "+(_dragging ? "dragging" : "decelerating")+" @(x="+scrollX+", y="+scrollY+")");			// notifying other views.			contentDidScroll(_scrollRect.clone());				this.dispatchEvent(new Event(Event.SCROLL));		}				/**		 * Triggerd when the user's releases the mouse and stops the dragging.		 */		private function dragStop(e:Event):void{			stage.removeEventListener(MouseEvent.MOUSE_UP,dragStop);			stage.removeEventListener(Event.MOUSE_LEAVE,dragStop);			_decelerating = true;			_dragging = false;			log("dragging did end with "+e.type);			if(_verticalIndicator && !_verticalIndicator.alwaysVisible && !_showVerticalIndicator){				verticalIndicator.visible = false;			}						if(_horizontalIndicator && !horizontalIndicator.alwaysVisible && !_showHorizontalIndicator){				horizontalIndicator.visible = false;			}		}				/**		 * Triggerd when mouse scrolling is resived via JavaScript injection.		 */		private function scrollWheelMoved(e:UIScrollEvent):void{			var change:Boolean = false;			// determine scroll velocity.			if(_alwaysBounceVertical || canScrollVertical){				vy += e.deltaY;					change = true;			}						if(_alwaysBounceHorizontal || canScrollHorizontal){				vx += e.deltaX;				change == true			}			// determine if scroll view is deceleration or moving.			if(change && !_decelerating){				this.addEventListener(Event.ENTER_FRAME,dragMove);			}		}				/**		 * Triggerd as the user is manualy scrolling the view with the vertical indicator.		 */		private function onVScroll(e:Event):void{			scrollY = Math.floor((_content.height-m_mask.height)*_verticalIndicator.procent);			contentDidScroll(_scrollRect.clone());			this.dispatchEvent(new Event(Event.SCROLL));		}				/**		 * Triggerd as the user is manualy scrolling the view with the horizontal indicator.		 */		private function onHScroll(e:Event):void{			scrollX = Math.floor((_content.width-width)*_horizontalIndicator.procent);			contentDidScroll(_scrollRect.clone());			this.dispatchEvent(new Event(Event.SCROLL));		}				//------------------------------------		// Managing Scrolling.		//------------------------------------						/**		 * 		 * @param rect		 * @param animated		 */		public function scrollRectToVisible(rect:Rectangle,animated:Boolean):void{					}							/**		 * Triggerd as the content view is scrolled.		 * 		 * @param bounds The Bounds that are currently visible in the content view.		 */		public function contentDidScroll(bounds:Rectangle):void{					}				/**		 * A Boolean value that determine whether the scroll view currently can scroll horizontaly.		 */		private function get canScrollHorizontal():Boolean{			return _content && scrollEnabled && _content.width > width;		}				/**		 * A Boolean value that determine whether the scorll view currently can scroll verticaly.		 */		private function get canScrollVertical():Boolean{			return _content && scrollEnabled && _content.height > height;		}											//------------------------------------		// Zooming and Panning		//------------------------------------				/**		 * With the <code>zoomTo</code> method the scroll view zoomes to a specific region of intrest.		 */		public final function zoomTo(rect:Rectangle,animated:Boolean):void{			var scale:Number;			// determine scale by aspect ratio change.			if(rect.width/width > rect.height/height){				scale = _zoomScale*(rect.width/width);			}else{				scale = _zoomScale*(rect.height/height);			}						//trace("UIScrollView.zoomTo:"+rect.toString()+" ,animated:"+animated);		}				/**		 * A Number determine the zoom scale onto the content.		 * 		 * <p>When zooming onto a content of <code>Bitmap</code> or <code>UIImageView</code>		 * scales above <code>8.5</code> may fail to render.</p>		 * 		 * @see UIScrollView.setZoomScale()		 * @see UIScrollView.minimumZoomScale		 * @see UIScrollView.maximumZoomScale		 */		public final function set zoomScale(value:Number):void{			setZoomScale(value,false);		}		// returns the value of the zoomScale attribute.		public final function get zoomScale():Number{			return _zoomScale;		}				/**		 * 		 * @see UIScrollView.minimumZoomScale		 * @see UIScrollView.maximumZoomScale		 */		public final function setZoomScale(value:Number,animated:Boolean):void{			value = Math.min(Math.max(value,_minimumZoomScale),_maximumZoomScale);			if(value != _zoomScale){				if(animated){					Tween.to(this,0.33,{zoomScale:value}).start();				}else{					var center:Point = _content.globalToLocal(localToGlobal(new Point(width*0.5,height*0.5)));					// determine scale.					_content.scaleX = _content.scaleY = value;					// determine center.					_content.x = Math.round(center.x*value);					_content.y = Math.round(center.y*value);					// TODO: determine center of zooming.				}			}			this.needsLayout();						// TODO: set the position of the content from the orgin in the view. not the orgin of the content						//trace("UIScrollView.setZoomScale:",value,",animated:"+animated);		}				/**		 * A Number value that specifies the maximum scale factor that can be applied to the scroll view's content.		 * 		 * @default <code>1.0</code>		 */		public function set maximumZoomScale(value:Number):void{			_maximumZoomScale = value;		}		// returns the value of the maximumZoomScale attribute.		public function get maximumZoomScale():Number{			return _maximumZoomScale;		}						/**		 * A Number value that specifies the minimum scale factor that can be applied to the scroll view's content.		 * 		 * @default <code>1.0</code>		 */		public function set minimumZoomScale(value:Number):void{			_minimumZoomScale = value;		}		// returns the value of the minimumZoomScale attribute.		public function get minimumZoomScale():Number{			return _minimumZoomScale;		}				/**		 * A <code>Boolean</code> value that determine whether the scroll view is currently zooming.		 */		public final function get zooming():Boolean{			return _zooming;		}								//------------------------------------		// Updating Content Displayed.		//------------------------------------				/**		 * @inheritDoc		 */		override protected function layout(rect:Rectangle):void{			// Showing and hidding vertical scroller.			if(canScrollVertical){				verticalIndicator.visible = true;				verticalIndicator.ratio = height/_content.height;			}else if(_verticalIndicator && !_alwaysShowIndicators && !_showVerticalIndicator){				_verticalIndicator.visible = false;			}			// Showing and Hidding horizontal scroller.			if(canScrollHorizontal){				horizontalIndicator.visible = true;				horizontalIndicator.ratio = width/_content.width;			}else if(_horizontalIndicator && !_alwaysShowIndicators && !_showHorizontalIndicator){				_horizontalIndicator.visible = false;			}			// Resizing and adjusting vertical indicator if shown.			if(_verticalIndicator && _verticalIndicator.visible){				_verticalIndicator.height = _horizontalIndicator && _horizontalIndicator.visible ? rect.height - 12 : rect.height - 4;				_verticalIndicator.x = rect.width-9;			}			// Resizing and adjusting horizontal indicator if shown.			if(_horizontalIndicator && _horizontalIndicator.visible){				_horizontalIndicator.width = _verticalIndicator && _verticalIndicator.visible ? rect.width - 12 : rect.width - 4;				_horizontalIndicator.y = rect.height - 9;			}			// Resizing content mask to current size.			m_mask.width = _scrollRect.width = rect.width;			m_mask.height = _scrollRect.height = rect.height;		}				/**		 * @inheritDoc		 */		override protected function draw(rect:Rectangle):void{			this.graphics.clear();			this.graphics.beginFill(0xFFFFFF);			this.graphics.drawRect(0,0,rect.width,rect.height);			this.graphics.endFill();		}				//------------------------------------		// Deconstruction		//------------------------------------				/**		 * @inheritDoc		 */		override public function dispose():void{			// destoying the super implemenation.			super.dispose();		}				//------------------------------------		// Other 		//------------------------------------				/**		 * @inheritDoc		 */				public override function toString():String{			return "[UIScrollView frame = " + _bounds.toString() + " contentScrollRect = " + this._scrollRect.toString() + " ]";		}			}}