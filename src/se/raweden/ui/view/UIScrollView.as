package se.raweden.ui.view{			import caurina.transitions.Tweener;		import flash.display.DisplayObjectContainer;	import flash.display.Shape;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Point;	import flash.geom.Rectangle;		import se.raweden.core.core;	import se.raweden.ui.events.UIScrollEvent;		/**	 * A <code>UIScrollView</code> component enables users to scroll within content	 * that is larger than the actual shown portion of the view. It enables users 	 * to scroll by using the mouse or the swipe gesture on a touch device and to	 * zoom back and forth using the pinching gestures. 	 * 	 * @copyright Copyright 2011 Raweden. All rights reserved. 	 * @author Raweden	 */	public class UIScrollView extends UIView{						//		// TODO: fix dragMove section where dragging is fixed to its bounds, its doesn't work when content is less than view.		// TODO: add zooming capibitly, using rectangular area to scale the content view.		// TODO: remove glitcy behaivor on buncing.		// TODO: add paging logics.		// TODO: add logics based on input device.		// TODO: show overlay scrollers when mouse is over the view on pc.		// TODO: add support with magic-mouse and trackpad on mac.		//		// TODO: disable mouseChildren on the content when scrolling.		// TODO: stop dragging as mouses leaves stage.		//				use namespace core;				// static constants.		private static const THRESHOLD:Number = 0.24;			// The smallest allowed velocity threshold.		private static const BOUNCING_SPRINGESS:Number = 0.45;	// The springess of the bouncing behavior.		private static const THROW_DECAY:Number = 0.92;				// content related variabels.		private var m_content:DisplayObjectContainer;		private var m_scrollRect:Rectangle = new Rectangle(0,0);		private var m_mask:Shape;		// scrollview general behvavior.		private var m_scrollEnabled:Boolean = true;		private var m_pagingEnabled:Boolean = false;		// bouncing and scrolling.		private var m_offset:Point = new Point();		private var m_mouse:Point = new Point();		private var vy:Number = 0;		private var vx:Number = 0;		// bouncing behvaior.		private var m_alwaysBounceHorizontal:Boolean = false;		private var m_alwaysBounceVertical:Boolean = false;		private var m_bounces:Boolean = true;		private var m_dragging:Boolean = false;		private var m_decelerating:Boolean = false;		// this boolean also indicates if the enterFrame listners is added.		// overlay scrollers related properties.		private var m_alwaysShowIndicators:Boolean = false;		private var m_showVerticalIndicator:Boolean = true;		private var m_showHorizontalIndicator:Boolean = true;		private var hScroller:UIScroller;		private var vScroller:UIScroller;		// zooming and panning 		private var m_zoomScale:Number = 1.0;		private var m_maximumZoomScale:Number = 1.0;		private var m_minimumZoomScale:Number = 1.0;		private var m_zooming:Boolean;						/**		 * 		 */		public function UIScrollView(parent:DisplayObjectContainer = null, content:UIView = null){			super(parent);			// initlizes the scroll view.			addChildren();			init();			// specifies the content			this.content = content;		}				// adds child component and display objects to the scrollview.		private function addChildren():void{			m_mask = new Shape();			m_mask.graphics.beginFill(0x000000);			m_mask.graphics.drawRect(0,0,100,100);			m_mask.graphics.endFill();			this.addChild(m_mask);			this.hScroller;			this.vScroller;		}				// initilizes the scroll view.		private function init():void{			this.addEventListener(UIScrollEvent.SCROLL,scrollWheelMoved);		}				//------------------------------------		// Managing Scrolling		//------------------------------------				/**		 * A Boolean value that determines if scrolling is enabled in the scroll view.		 */		public function set scrollEnabled(value:Boolean):void{			m_scrollEnabled = value;		}		// Indicates if scrolling is enabled.		public function get scrollEnabled():Boolean{			return m_scrollEnabled;		}				/**		 * A Boolean valie tath determines whether paging is enabled for the scroll view.		 * 		 * <p>If this value is set to <code>true</code>, the scroll view stops on the nearest 		 * multiple if the scroll view's bounds when the user scrolls.</p>		 * 		 * @default <code>false</code>		 */		public function set pagingEnabled(value:Boolean):void{			m_pagingEnabled = value;		}		// indicates if paging is enabled.		public function get pagingEnabled():Boolean{			return m_pagingEnabled;		}				/**		 * A Boolean value that controls whether the scroll view bounces past the edge of the content and back again.		 *  		 * @default <code>true</code>		 */		public function set bounces(value:Boolean):void{			m_bounces = value;		}		// indicetes if bounces is to be used.		public function get bounces():Boolean{			return m_bounces;		}						/**		 * A Boolean value that determines whether bouncing allways occurs when vertical scrolling reaches the end of the content view.		 * 		 * @default <code>false</code>		 */		public function set alwaysBounceVertical(value:Boolean):void{			m_alwaysBounceVertical = value;		}		//		public function get alwaysBounceVertical():Boolean{			return m_alwaysBounceVertical;		}				/**		 * A Boolean value that determines whether bouncing allways occurs when horizontal scrolling reaches the end of the content view.		 * 		 * <code>false</code>		 */		public function set alwaysBounceHorizontal(value:Boolean):void{			m_alwaysBounceHorizontal = value;		}		//		public function get alwaysBounceHorizontal():Boolean{			return m_alwaysBounceHorizontal;		}					/**		 * A Boolean value that indicates whether the user has begun scrolling the content.		 */		public function get dragging():Boolean{			return m_dragging;		}				/**		 * A Boolean value that indicates whether the scroll view is currently decelerating after scrolling the content.		 */		public function get decelerating():Boolean{			return m_decelerating;		}				//------------------------------------		// Managing Scroll Indicators.		//------------------------------------				public function set scrollX(value:Number):void{			m_content.x = -value;			m_scrollRect.x = value;			// not implemeneted.		}				public function get scrollX():Number{			return m_scrollRect.x;		}				public function set scrollY(value:Number):void{			m_content.y = -value;			m_scrollRect.y = value;			// not implemented.		}				public function get scrollY():Number{			return m_scrollRect.y;		}				//------------------------------------		// Managing Overlay Scrollers.		//------------------------------------				/**		 * 		 */		public function set alwaysShowIndicators(value:Boolean):void{			if(m_alwaysShowIndicators != value){				if(hScroller){					hScroller.alwaysVisible = value;				}				if(vScroller){					vScroller.alwaysVisible = value;				}				m_alwaysShowIndicators = value;			}		}		//		public function get alwaysShowIndicators():Boolean{			return m_alwaysShowIndicators;		}				/**		 * 		 */		public function set showHorizontalIndicator(value:Boolean):void{			m_showHorizontalIndicator = value;		}		//		public function get showHorizontalIndicator():Boolean{			return m_showHorizontalIndicator;		}				/**		 * 		 */		public function set showVerticalIndicator(value:Boolean):void{			m_showVerticalIndicator = value;		}		//		public function get showVerticalIndicator():Boolean{			return m_showVerticalIndicator;		}				/**		 * Displays the scrollers for a monent to indicate to the user that there is more to see.		 */		public function flashIndicators():void{			if(vScroller && !m_alwaysShowIndicators){				vScroller.flash();			}			if(hScroller && !m_alwaysShowIndicators){				hScroller.flash();			}		}				//------------------------------------		// Setting and Getting Content View.		//------------------------------------				/**		 * 		 */		public function set content(value:DisplayObjectContainer):void{			if(m_content){				m_content.removeEventListener(Event.RESIZE,onContentResize);				m_content.removeEventListener(MouseEvent.MOUSE_DOWN,dragStart);				// removing the mask from the old content.				if(m_content.mask == m_mask){					m_content.mask = null;				}				// removing the content from the scrollview.				if(this.contains(m_content)){					this.removeChild(m_content);				}			}			m_content = value;			if(m_content){				m_content.addEventListener(Event.RESIZE,onContentResize);				m_content.addEventListener(MouseEvent.MOUSE_DOWN,dragStart);				this.addChildAt(m_content,0);				m_content.mask = m_mask;			}			// refrehing the layout.			this.setNeedsLayout();		}		// returns the current content container.		public function get content():DisplayObjectContainer{			return m_content;		}						// responding the the resize of the content view.		private function onContentResize(e:Event):void{			this.setNeedsLayout();		}				//------------------------------------		// Responding to user Interaction and Dragging and Throwing the content view.		//------------------------------------								// triggerd when as the user begins dragging the content view.		private function dragStart(e:MouseEvent):void{				m_dragging = true;				stage.addEventListener(MouseEvent.MOUSE_UP,dragStop);				stage.addEventListener(Event.MOUSE_LEAVE,dragStop);				// Register for enter frame listener to drag the content and animate the scrolling and bounces.				if(!m_decelerating){					this.addEventListener(Event.ENTER_FRAME,dragMove);					//trace("did start scroll animation");				}								// TODO: carculate mouse offset when contnet is scaled, current impl don't works.								// Getting Local offset relative to the content.				m_offset.x = m_content.mouseX;				m_offset.y = m_content.mouseY;				//trace("offset:",m_offset);				m_mouse.x = this.mouseX;				m_mouse.y = this.mouseY;				vy = 0;				vx = 0;		}						// triggerd as the user is dragging or throwing the content view.		private function dragMove(e:Event):void{			var x:Number;			var y:Number;			var max_x:Number = canScrollHorizontal ? -Math.abs(m_content.width-width) : 0;			var max_y:Number = canScrollVertical ? -Math.abs(m_content.height-height) : 0;			// 			if(m_dragging){				// getting where the content should be draged.				x = this.mouseX-m_offset.x;				y = this.mouseY-m_offset.y;				// getting the velocity.				vx = this.mouseX-m_mouse.x;				vy = this.mouseY-m_mouse.y;				// setting reference.				m_mouse.x = this.mouseX;				m_mouse.y = this.mouseY;				// constrains the paning of the content based up on setup - Horizontaly.				if(!m_alwaysBounceHorizontal){					if(x > 0){						vx = 0;						x = 0;					}else if(x < max_x){						vx = 0;						x = max_x;					}						}				// constrains the paning of the content based up on setup - Verticaly.				if(!m_alwaysBounceVertical){					if(y > 0){						vy = 0;						y = 0;					}else if(y < max_y){						vy = 0;						y = max_y;					}						}			}else{				var bx:Number = 0;				var by:Number = 0;								x = m_content.x;				y = m_content.y;				// constrains the horizontal bounds to the content bounds.				if(m_bounces){					// determine the horinzontal bounce.					if(x > 0 || max_x > 0){						bx = -x * BOUNCING_SPRINGESS;					}else if(x < max_x){						bx = (max_x - x) * BOUNCING_SPRINGESS;					}							// determine the vertical bounce.					if(y > 0 || max_y > 0){						by = -y * BOUNCING_SPRINGESS;					}else if(y < max_y){						by = (max_y - y) * BOUNCING_SPRINGESS;					}							// determine content final offset.					x = x+vx+bx;					y = y+vy+by;				}else{					// constrains the horizontal bounds to the content bounds.					if(x > 0){						vx = 0;						x = 0;					}else if(x < max_x){						vx = 0;						x = max_x;					}					// constrains the vertical bounds to the content bounds.					if(y > 0){						vy = 0;						y = 0;					}else if(y < max_y){						vy = 0;						y = max_y;					}						// determine content final offset.					x = x+vx;					y = y+vy;				}				// decay of velocity (friction).				vy *= THROW_DECAY;				vx *= THROW_DECAY;				// determine if velocity is enough to animate the content offset.				var tx:Boolean = Math.abs(vx) < THRESHOLD;				var ty:Boolean = Math.abs(vy) < THRESHOLD;				vx = tx ? 0 : vx;				vy = ty ? 0 : vy;				tx = tx && Math.abs(bx) == 0;				ty = ty && Math.abs(by) == 0;				// determine of both values is below the threshold.				if(tx && ty){					this.removeEventListener(Event.ENTER_FRAME,dragMove);					m_decelerating = false;				}			}			var a:int;			if(vScroller){				vScroller.procent = y/max_y;				a = 0;				if(y > 0){					a = y;				}else if(y < max_y){					a = Math.abs(y-max_y);				}				vScroller.ratio = height/(a+m_content.height);			}			if(hScroller){				hScroller.procent = x/max_x;				a = 0;				if(x > 0){					a = x;				}else if(x < max_x){					a = Math.abs(x-max_x);				}				hScroller.ratio = width/(a+m_content.width);			}			// setting the final positon of the content.			//log("content is "+(m_dragging ? "dragging" : "decelerating")+" @(x="+scrollX+", y="+scrollY+")");			this.scrollX = -x;			this.scrollY = -y;			// notifying other views.			contentDidScroll(m_scrollRect.clone());				this.dispatchEvent(new Event(Event.SCROLL));		}				// triggerd when the user's releases the mouse and stops the dragging.		private function dragStop(e:Event):void{			stage.removeEventListener(MouseEvent.MOUSE_UP,dragStop);			stage.removeEventListener(Event.MOUSE_LEAVE,dragStop);			m_decelerating = true;			m_dragging = false;			log("dragging did end with "+e.type);						/*			// if paging is enabled, this code snaps to the closest content page bounds.			if(m_pagingEnabled){				var pageSize:Point = m_bounds.size.clone();				var numPages:Point = new Point(Math.floor(m_content.width/pageSize.x), Math.floor(m_content.height/pageSize.y));				var rawPage:Point = new Point(m_scrollRect.x/pageSize.x,m_scrollRect.y/pageSize.y);				var curPage:Point = new Point(Math.floor(rawPage.x),Math.floor(rawPage.y));				var pagePer:Point = new Point(1-(rawPage.x-curPage.x),1-(rawPage.y-curPage.y));				var offset:Point = new Point();								// if current page per(centage) is less tahn 50%, then go to the next page (if any), otherwise snap to the current page.				if(curPage.x < 0.5 && curPage.x+1 < numPages.x){					offset.x = pageSize.x * (curPage.x+1);				}else{					offset.y = pageSize.x * curPage.x				}				// the same as above but with vertical paging.				if(pagePer.y < 0.5 && (curPage.y+1) < numPages.y){					offset.y = pageSize.y * (curPage.y+1);				}else{					offset.y = pageSize.y * curPage.y;				}			}			*/		}				// triggerd when mouse scrolling is resived via JavaScript injection.		private function scrollWheelMoved(e:UIScrollEvent):void{			var change:Boolean = false;			// determine scroll velocity.			if(m_alwaysBounceVertical || canScrollVertical){				vy += e.deltaY;					change = true;			}						if(m_alwaysBounceHorizontal || canScrollHorizontal){				vx += e.deltaX;				change == true			}			// determine if scroll view is deceleration or moving.			if(change && !m_decelerating){				this.addEventListener(Event.ENTER_FRAME,dragMove);			}		}				// triggerd as the user is manualy scrolling the view with the vertical overlay scroller.		private function onVScroll(e:Event):void{			scrollY = Math.floor((m_content.height-m_mask.height)*vScroller.procent);			contentDidScroll(m_scrollRect.clone());			this.dispatchEvent(new Event(Event.SCROLL));		}				// triggerd as the user is manualy scrolling the view with the horizontal overlay scroller.		private function onHScroll(e:Event):void{			scrollX = Math.floor((m_content.width-width)*hScroller.procent);			contentDidScroll(m_scrollRect.clone());			this.dispatchEvent(new Event(Event.SCROLL));		}		//------------------------------------				// Managing Overlay Scrollers		//------------------------------------						//------------------------------------		// Managing Scrolling.		//------------------------------------						/**		 * 		 */		public function scrollRectToVisible(rect:Rectangle,animated:Boolean):void{					}							/**		 * Triggerd as the content view is scrolled.		 * 		 * @param bounds The Bounds that are currently visible in the content view.		 */		public function contentDidScroll(bounds:Rectangle):void{					}				/**		 * A Boolean value that determine whether the scroll view currently can scroll horizontaly.		 */		private function get canScrollHorizontal():Boolean{			return m_content && scrollEnabled && m_content.width > width;		}				/**		 * A Boolean value that determine whether the scorll view currently can scroll verticaly.		 */		private function get canScrollVertical():Boolean{			return m_content && scrollEnabled && m_content.height > height;		}											//------------------------------------		// Zooming and Panning		//------------------------------------				/**		 * With the <code>zoomTo</code> method the scroll view zoomes to a specific region of intrest.		 */		public final function zoomTo(rect:Rectangle,animated:Boolean):void{			var scale:Number;			// determine scale by aspect ratio change.			if(rect.width/width > rect.height/height){				scale = m_zoomScale*(rect.width/width);			}else{				scale = m_zoomScale*(rect.height/height);			}						//trace("UIScrollView.zoomTo:"+rect.toString()+" ,animated:"+animated);		}				/**		 * A Number determine the zoom scale onto the content.		 * 		 * <p>When zooming onto a content of <code>Bitmap</code> or <code>UIImageView</code>		 * scales above <code>8.5</code> may fail to render.</p>		 * 		 * @see UIScrollView.setZoomScale()		 * @see UIScrollView.minimumZoomScale		 * @see UIScrollView.maximumZoomScale		 */		public final function set zoomScale(value:Number):void{			setZoomScale(value,false);		}		// returns the current zoom scale.		public final function get zoomScale():Number{			return m_zoomScale;		}				/**		 * 		 * @see UIScrollView.minimumZoomScale		 * @see UIScrollView.maximumZoomScale		 */		public final function setZoomScale(value:Number,animated:Boolean):void{			value = Math.min(Math.max(value,m_minimumZoomScale),m_maximumZoomScale);			if(value != m_zoomScale){				if(animated){					Tweener.addTween(this,{zoomScale:value,time:0.33});				}else{					var center:Point = m_content.globalToLocal(localToGlobal(new Point(width*0.5,height*0.5)));					// determine scale.					m_content.scaleX = m_content.scaleY = value;					// determine center.					m_content.x = Math.round(center.x*value);					m_content.y = Math.round(center.y*value);					// TODO: determine center of zooming.				}			}			this.setNeedsLayout();						// TODO: set the position of the content from the orgin in the view. not the orgin of the content						//trace("UIScrollView.setZoomScale:",value,",animated:"+animated);		}				/**		 * A Number value that specifies the maximum scale factor that can be applied to the scroll view's content.		 * 		 * @default <code>1.0</code>		 */		public function set maximumZoomScale(value:Number):void{			m_maximumZoomScale = value;		}		// returns the current maximum zoom scale.		public function get maximumZoomScale():Number{			return m_maximumZoomScale;		}						/**		 * A Number value that specifies the minimum scale factor that can be applied to the scroll view's content.		 * 		 * @default <code>1.0</code>		 */		public function set minimumZoomScale(value:Number):void{			m_minimumZoomScale = value;		}		// returns the current minimum zoom scale.		public function get minimumZoomScale():Number{			return m_minimumZoomScale;		}				/**		 * A Boolean value that determine whether the scroll view is currently zooming.		 */		public final function get zooming():Boolean{			return m_zooming;		}								//------------------------------------		// Updating Content Displayed.		//------------------------------------				/**		 * @inheritDoc		 */		override protected function layout(rect:Rectangle):void{			// Showing and hidding vertical scroller.			if(canScrollVertical){				if(!vScroller){					vScroller = new UIScroller(this);					vScroller.y = 2;					vScroller.addEventListener(Event.SCROLL,onVScroll);				}				vScroller.visible = true;				vScroller.ratio = height/m_content.height;			}else if(vScroller && !m_alwaysShowIndicators && !m_showVerticalIndicator){				vScroller.visible = false;			}			// Showing and Hidding horizontal scroller.			if(canScrollHorizontal){				if(!hScroller){					hScroller = new UIScroller(this);					hScroller.direction = UIScroller.DIRECTION_HORIZONTAL;					hScroller.x = 2;					hScroller.addEventListener(Event.SCROLL,onHScroll);				}				hScroller.visible = true;				hScroller.ratio = width/m_content.width;			}else if(hScroller && !m_alwaysShowIndicators && !m_showHorizontalIndicator){				hScroller.visible = false;			}			// Resizing and adjusting veritical scroller if shown.			if(vScroller && vScroller.visible){				hScroller				vScroller.height = hScroller && hScroller.visible ? rect.height-12 : rect.height-4;				vScroller.x = rect.width-9;			}			// Resizing and adjusting horizontal scroller if shown.			if(hScroller && hScroller.visible){				hScroller.width = vScroller &&  vScroller.visible ? rect.width-12 : rect.width-4;				hScroller.y = rect.height-9;			}			// Masking content to the current size.			m_mask.width = m_scrollRect.width = rect.width;			m_mask.height = m_scrollRect.height = rect.height;		}				/**		 * @inheritDoc		 */		override protected function draw(rect:Rectangle):void{			this.graphics.clear();			this.graphics.beginFill(0xFFFFFF,0.001);			this.graphics.drawRect(0,0,rect.width,rect.height);			this.graphics.endFill();		}				//------------------------------------		// Deconstruction		//------------------------------------				/**		 * @inheritDoc		 */		override public function dispose():void{			// destoying the super implemenation.			super.dispose();		}				//------------------------------------		// Other 		//------------------------------------				/**		 * @inheritDoc		 */				public override function toString():String{			return "[UIScrollView frame = "+m_bounds.toString()+" contentScrollRect = "+this.m_scrollRect.toString()+" ]";		}			}}