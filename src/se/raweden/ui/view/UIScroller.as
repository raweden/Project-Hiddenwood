////	UIScroller.as//	Core UI Framework////	Created by Raweden on 2011-05-22//	Copyright 2011 Raweden. Some rights reserved.//package se.raweden.ui.view{	import flash.display.DisplayObjectContainer;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Point;	import flash.geom.Rectangle;		import se.raweden.core.core;
			/**	 * A <code>UIScroller</code> component is a simple overlay scroller.	 * 	 * @author Raweden	 */	public class UIScroller extends UIControl{				use namespace core;				// static constats		public static const DIRECTION_VERTICAL:String = "vertical";		public static const DIRECTION_HORIZONTAL:String = "horizontal";				private var m_procent:Number = 0;		private var m_direction:String = DIRECTION_VERTICAL;		private var m_ratio:Number = 0.25;		private var m_hit:Point;		private var hitX:int;		private var hitY:int;				private var thumb:Sprite		private var track:Sprite;				/**		 * 		 */		public function UIScroller(parent:DisplayObjectContainer = null){			super(parent);			addChildren();			init();		}					private function init():void{			this.resize(8,256);		}				private function addChildren():void{			// creating the track.			track = new Sprite();			track.addEventListener(MouseEvent.CLICK,onTrackClick);			this.addChild(track);			// creating the thumb.			thumb = new Sprite();			thumb.addEventListener(MouseEvent.MOUSE_DOWN,dragStart);			this.addChild(thumb);		}				//------------------------------------ 		// Responding to User Interaction.		//------------------------------------		// triggers as the scroll track is clicked by the user.		private function onTrackClick(e:MouseEvent):void{			//var procent:Number = track.mouseY / track.height;			//this.procent = procent;		}				// triggerd when the user presses down the handle.		private function dragStart(e:MouseEvent):void{			m_hit = new Point(thumb.mouseX,thumb.mouseY);			stage.addEventListener(MouseEvent.MOUSE_MOVE,dragMove);			stage.addEventListener(MouseEvent.MOUSE_UP,dragStop);		}				// triggerd when the mouse moves over the stage after the handle have been pressed down.		private function dragMove(e:MouseEvent):void{			var max:int; 			var min:int;			var v:int;			if(m_direction == "vertical"){				// carculating maximum and minimal output value.				max = m_height-thumb.height;				min = 0;				// applaying logics.				v = mouseY-m_hit.y;				v = v < min ? min : v;				v = v > max ? max : v;				// setting thumb vertical position.				thumb.y = v;			}else{				// carculating maximum and minimal output value.				max = m_width-thumb.width;				min = 0;				// applying logics.				v = mouseX-m_hit.x;				v = v < min ? min : v;				v = v > max ? max : v;				// setting thumb horizontal position.				thumb.x = v;			}			// carculating scroll procentage.			var procent:Number = v/max;			if(procent != m_procent){				m_procent = procent;				this.dispatchEvent(new Event(Event.SCROLL));			}			e.updateAfterEvent();		}				// triggerd when the mouse relases over the stage after the handle have been pressed down.		private function dragStop(e:MouseEvent):void{			m_hit = null;			stage.removeEventListener(MouseEvent.MOUSE_MOVE,dragMove);			stage.removeEventListener(MouseEvent.MOUSE_UP,dragStop);		}				//------------------------------------		// Getting and Setting Attributes.		//------------------------------------				/**		 * A Number representing the procentage the Handle is down the track.		 * 		 * @default <code>0.0</code>		 */		public function set procent(value:Number):void{			value = value < 0 ? 0 : value;			value = value > 1 ? 1 : value;			if(value == m_procent)return;			m_procent = value;			this.dispatchEvent(new Event(Event.CHANGE));			// setting handle position by animation.			if(m_direction == DIRECTION_VERTICAL){				thumb.y = int(value*(m_height - thumb.height));				}else{				thumb.x = int(value*(m_width - thumb.width));			}		}		// returns if the Switch is currently selected.		public function get procent():Number{			return(m_procent);		}				/**		 * A Number representing the ratio of the content length to the visible length.		 * 		 * @default <code>0.5</code>		 */		public function set ratio(value:Number):void{			value = value > 1 ? 1 : value;			value = value < 0 ? 0 : value;			if(m_ratio == value)return;			enabled = value > 0 && value < 1;			m_ratio = value;			this.setNeedsDisplay();		}		// returns the current ratio.		public function get ratio():Number{			return(m_ratio);		}				/**		 * 		 * 		 * @default <code>UIScroller.DIRECTION_VERTICAL</code>		 */		public function set direction(value:String):void{			value = value == DIRECTION_VERTICAL || value == DIRECTION_HORIZONTAL ? value : DIRECTION_VERTICAL			if(value != m_direction){				this.resize(m_height,m_width);				m_direction = value;				this.setNeedsDisplay();			}		}		// returns the current direction.		public function get direction():String{			return(m_direction);		}			//------------------------------------		// Draw the graphics onto the Sub Components.		//------------------------------------						/**		 * @private;		 */		protected override function draw(rect:Rectangle):void{			var w:int = rect.width;			var h:int = rect.height;			var d:Boolean = (m_direction == DIRECTION_VERTICAL);			var r:Number = m_ratio;			// draws the track.			track.graphics.clear();			track.graphics.beginFill(0x2D2D2D,0.1);			if(d){				track.graphics.drawRoundRect(0,0,w,h,w,w) 			}else{				track.graphics.drawRoundRect(0,0,w,h,h,h);			}			track.graphics.endFill();			// draws the thumb.			thumb.graphics.clear();			thumb.graphics.beginFill(0x000000,0.50);			if(d){				thumb.graphics.drawRoundRect(0,0,w,int(h*r),w,w)			}else{				thumb.graphics.drawRoundRect(0,0,int(w*r),h,h,h);			}			// adjusting the position of the thumb.			if(d){				thumb.y = int(m_procent*(m_height - thumb.height));				}else{				thumb.x = int(m_procent*(m_width - thumb.width));			}		}				//------------------------------------		// Deconstruction		//------------------------------------				/**		 * @private;		 */		override public function destroy():void{						// destoying the super implemenation.			super.destroy();		}			}}