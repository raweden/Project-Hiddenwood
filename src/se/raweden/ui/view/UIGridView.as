package se.raweden.ui.view{	import flash.display.DisplayObjectContainer;	import flash.events.MouseEvent;	import flash.geom.Rectangle;		import se.raweden.desktop.UIDragging;	import se.raweden.ui.events.UITableEvent;
		/**	 * A <code>UICollectionView</code>	 *	 * <p>Copyright 2011, Raweden. All Rights Reserved.</p>	 *	 * @author Raweden	 */	public class UIGridView extends UIScrollView{				//		// TODO: Add support for both directions.		// TODO: Implement the data source and dataSource in a diffrent way.		// TODO: Add support for drag-and-drop.		//				public var _content:UIView;				private var _dataSource:IGridViewDataSource;				private var _position:int = 0;		private var _length:int = -1;		private var _visibleCells:Array;		private var _reuseableCells:Array;		private var _orientation:String;		// cell configuration.		private var _cellWidth:int = 120;		private var _cellHeight:int = 120;		// selection.		private var _allowMultibleSelection:Boolean;		private var _selected:Array;				/**		 * Constructor.		 */		public function UIGridView(parent:DisplayObjectContainer = null){			super(parent);			addChildren();			init();			// setting the default size.			this.resize(480,320);		}				/**		 * 		 */		private function addChildren():void{			super.content = _content = new UIView();			_content.resize(480,320);		}				/**		 * 		 */		private function init():void{			// setting up default values for the Collection View.			this.doubleClickEnabled = true;			// adding arrays to contains valuable cell information.			_visibleCells = new Array();			_reuseableCells = new Array();			_selected = new Array();		}				//------------------------------------		// Handeling Cell creation and reuse.		//------------------------------------				/**		 * <b>Required</b> delegation method.		 * The method is invoked each time a cell at a certain index will be 		 * added to the display list, the dataSource method should return a 		 * UITableViewCell subclass and it's recommend to use the <code>reuseableCell()</code> method.		 * The default value is <code>null</code> and this method is <b>required</b>.		 * <p><code>function cellProvider(index:int):UITableViewCell</code></p>		 * @default <code>null</code>		 */		public function set dataSource(value:IGridViewDataSource):void{			if(value){				_dataSource = value;					this.reload();			}else{				_dataSource = null;			}			init();		}		// returns the current data source.		public function get dataSource():IGridViewDataSource{			return _dataSource;		}				/**		 * 		 */		public function reuseableCell(identifier:String):UITableViewCell{			var len:int = _reuseableCells.length;			var cell:UITableViewCell;			for(var i:int = 0;i<len;i++){				cell = _reuseableCells[i];				if(cell.identifier == identifier){					_reuseableCells.splice(i,1);					return cell;				}			}			return null;		}		/**		 * 		 */		public function set cellWidth(value:int):void{			_cellWidth = value;			this.needsLayout();		}		// return the current specified cell width.		public function get cellWidth():int{			return _cellWidth;		}		/**		 * 		 */		public function set cellHeight(value:int):void{			_cellHeight = value;			this.needsLayout();		}		// returns the current specified cell height.		public function get cellHeight():int{			return _cellHeight;		}				/**		 * A Enum value that determine which direction the cells is arranged and also the direction of scroll.		 */		public function set orientation(value:String):void{			value = value == "horizontal" || value == "vertical" ? value : "vertical";			if(value != _orientation){				_orientation = value;				this.needsLayout();			}		}		//		public function get orientation():String{			return _orientation;		}		//------------------------------------		// Accessing cells.		//------------------------------------				/**		 * 		 * 		 * @param cell		 * @return		 */		public function indexForCell(cell:UITableViewCell):int{			if(!cell)return -1;			// returns the cell index of a cell that is not null.			var index:int = _visibleCells.indexOf(cell);			return index != -1 ? index+_position : -1;		}				/**		 * 		 * @param index		 * @return		 */		public function cellForIndex(index:uint):UITableViewCell{			if(index < _visibleCells.length){				return _visibleCells[index];			}			return null;		}				/**		 * 		 * 		 * @param index		 * @return		 */		public function rectForCellAt(index:int):Rectangle{			var w:int = _cellWidth;			var h:int = _cellHeight;			var c:int = Math.floor(width/w);			var r:int = Math.floor(index/c);			c = index%c;			return new Rectangle(w*c,h*r,w,h);		}				/**		 * 		 * 		 * @param index		 * @return		 */		public function rowAt(index:int):int{			var c:int = Math.floor(width/_cellWidth);			return Math.floor(index/c);		}				/**		 * 		 */		public function get visibleCells():Array{			return _visibleCells.filter(filter);			// filters out all unused slots in the array.			function filter(cell:*,index:int,array:Array):Boolean{				return cell != null;			}		}				//------------------------------------		// Configuring cells		//------------------------------------		//------------------------------------		// Configuring Selection			//------------------------------------				/**		 * A Boolean value that determines if the user should be able to select more than one cell.		 * 		 * @default <code>false</code>		 */		public function set allowMultibleSelection(value:Boolean):void{			_allowMultibleSelection = value;		}		// returns boolean for whether mutlible selection is currently enabled.		public function get allowMultibleSelection():Boolean{			return _allowMultibleSelection;		}				/**		 * 		 */		public function set selectedIndex(value:int):void{					}		// returns the lastest selected index.		public function get selectedIndex():int{			return _selected.length > 0 ? _selected[_selected.length-1] : -1;		}				/**		 * 		 */		public function set selectedItems(value:Array):void{					}		// returns the indexes of all selected items.		public function get selectedItems():Array{			return null;		}				/**		 * Determines whether the index specified is flaged as selected.		 * 		 * @return <code>true</code> if the index is flaged as selected, otherwise <code>false</code>.		 */		public function isSelected(index:uint):Boolean{			return _selected.indexOf(index) != -1;		}				/**		 * Clears the current selection.		 */		public function clearSelection():void{			while(_selected.length > 0){				var cell:UITableViewCell = cellForIndex(_selected.pop());				if(cell){					cell.selected = false;				}			}		}				//------------------------------------		// Laying out cells		//------------------------------------				/**		 * Reloads the content, or a specific cell at the index if specified.		 * 		 * @param index The index of the cell to be reload or the default value to reload the hole collection view.		 * @throws RangeError if <code>index</code> parameter is specified to a value that is greater than the number of items and less than <code>-1</code>.		 */		public function reload(index:int = -1):void{			if(index != -1){				return reloadIndex(index);			}			// collects the olds cell and makes them ready for reuse.			while(_visibleCells.length > 0){				var cell:UITableViewCell = _visibleCells.shift();				if(cell){					if(_content.contains(cell)){						_content.removeChild(cell);						cell.removeEventListener(MouseEvent.CLICK,onCellClick);						cell.removeEventListener(MouseEvent.DOUBLE_CLICK,onDoubleClick);					}					cell.prepareForReuse();					this._reuseableCells.push(cell);				}			}			// adjusting the lenght of the list.			_length = _dataSource.numberOfCells();			_visibleCells.length = _length;			_content.height = (rowAt(_length) * _cellHeight);			trace("content-height:",_content.height);			// invalidates the layout.			this.clearSelection();			this.needsLayout();		}				/**		 * Reloads the cell at a specified index.		 */		private function reloadIndex(index:int):void{			if(index < 0 || index >= _visibleCells.length){				throw new RangeError("reload index is out of range");				}					}				//------------------------------------		// Updating Visual Apperance		//------------------------------------				/**		 * @inheritDoc		 */		override protected function layout(rect:Rectangle):void{			_content.width = rect.width;			// calling super before.			super.layout(rect);			// 			layoutView(rect);		}				/**		 * @inheritDoc		 */		override public function contentDidScroll(bounds:Rectangle):void{			layoutView(bounds);		}				/**		 * Arranages the currently visible cells.		 */		private function layoutView(bounds:Rectangle):void{			var cellRect:Rectangle;			var cell:UIGridViewCell;			for(var i:int = 0;i<_length;i++){				cellRect = rectForCellAt(i);				if(bounds.intersects(cellRect)){					cell = _visibleCells[i] != null ? _visibleCells[i] : _dataSource.cellAt(this,i);					if(cell){						cell.selected = isSelected(i);						cell.x = cellRect.x;						cell.y = cellRect.y;						cell.resize(cellRect.width,cellRect.height);						if(cell.parent != _content){							cell.addEventListener(MouseEvent.CLICK,onCellClick);							cell.addEventListener(MouseEvent.DOUBLE_CLICK,onDoubleClick);							_content.addChild(cell);							// we need to render the cell here to not get the glitchy delayed resizing behaivor.							cell.render();						}						_visibleCells[i] = cell;					}				}else{					cell = _visibleCells[i];					if(cell){						cell.prepareForReuse();						cell.removeEventListener(MouseEvent.CLICK,onCellClick);						cell.removeEventListener(MouseEvent.DOUBLE_CLICK,onDoubleClick);						if(cell.parent == _content){							_content.removeChild(cell);						}						_reuseableCells.push(cell);					}					_visibleCells[i] = null				}			}		}						//------------------------------------		// Responding to user Interaction.		//------------------------------------			/**		 * Handles the selection of the cells by the user clicking on cell.		 */		private function onCellClick(e:MouseEvent):void{			var cell:UITableViewCell = e.currentTarget as UITableViewCell;			var index:int = _visibleCells.indexOf(cell);			if(_allowMultibleSelection && e.shiftKey){				if(!isSelected(index)){					_selected.unshift(index);					cell.selected = true;				}else{					_selected.splice(_selected.indexOf(index),1);					cell.selected = false;				}			}else{				this.clearSelection();				_selected.unshift(index);				cell.selected = true;			}			this.dispatchEvent(new UITableEvent(UITableEvent.ITEM_CLICK,index));		}				/**		 * Respons to the event of the user double clicking on a cell.		 */		private function onDoubleClick(e:MouseEvent):void{			var cell:UITableViewCell = e.currentTarget as UITableViewCell;			var index:int = _visibleCells.indexOf(cell);			this.dispatchEvent(new UITableEvent(UITableEvent.ITEM_DOUBLE_CLICK,index));		}				//------------------------------------		// Deconstruction		//------------------------------------				/**		 * @inheritDoc		 */		override public function dispose():void{			// destoying the super implemenation.			super.dispose();		}
		
	}}