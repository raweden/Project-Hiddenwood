package se.raweden.ui.view{	import flash.display.DisplayObjectContainer;	import flash.events.MouseEvent;	import flash.geom.Rectangle;		import se.raweden.ui.events.UITableEvent;		/**	 * A <code>UITableView</code>	 *	 * Copyright 2011, Raweden. All Rights Reserved.	 *	 * @author Raweden	 */	public class UITableView extends UIScrollView{				//		// TODO: Another approach is needed for the delegation of the data source.		// TODO: Add API for selecting cells programmaticly (for restoring application state. etc)		// TODO: Add Support for drag-and-drop out of the box.		//				public var _content:UIView;				private var _dataSource:ITableViewDataSource;		private var _length:int = -1;		private var _visibleCells:Array;		private var _reuseableCells:Array;		// cell configuration.		private var _cellHeight:int = 48;		// selection.		private var _allowMultibleSelection:Boolean = false;		private var _selected:Array;				/**		 * Constructor.		 */		public function UITableView(parent:DisplayObjectContainer = null){			super(parent);			addChildren();			init();		}				private function addChildren():void{			super.content = _content = new UIView();		}				private function init():void{			// setting the default values for the table view.			this.doubleClickEnabled = true;			// setting up arrays that will dynamicly contain the cells.			_visibleCells = new Array();			_reuseableCells = new Array();			_selected = new Array();			// setting the default size.			resize(220,360);		}				//------------------------------------		// Handeling Cell creation and reuse.		//------------------------------------						public var viewForHeaderAt:Function;				public var viewForFooterAt:Function;				public var heightForHeaderAt:Function;				public var heightForFooterAt:Function;				/**		 * A Object containing the data source callbacks for this table view.		 * 		 * @default <code>null</code>		 */		public function set dataSource(value:ITableViewDataSource):void{			if(value){				var source:Object = value;				// setting view callback for view for footer.				if(source.hasOwnProperty("viewForHeaderAt") && source.viewForHeaderAt is Function){					this.viewForHeaderAt = source.viewForHeaderAt;				}				// setting view callback for view for footer.				if(source.hasOwnProperty("viewForFooterAt") && source.viewForFooterAt is Function){					this.viewForFooterAt = source.viewForFooterAt;				}				// setting view callback for view for footer.				if(source.hasOwnProperty("heightForHeaderAt") && source.heightForHeaderAt is Function){					this.heightForHeaderAt = source.heightForHeaderAt;				}				// setting view callback for view for footer.				if(source.hasOwnProperty("heightForFooterAt") && source.heightForFooterAt is Function){					this.heightForFooterAt = source.heightForFooterAt;				}								_dataSource = value;				this.reload();			}else{				_dataSource = null;			}		}		// indicates the current cell provider.		public function get dataSource():ITableViewDataSource{			return _dataSource;		}				/**		 * 		 */		public function reuseableCell(identifier:String):UITableViewCell{			var len:int = _reuseableCells.length;			var cell:UITableViewCell;			for(var i:int = 0;i<len;i++){				cell = _reuseableCells[i];				if(cell.identifier == identifier){					_reuseableCells.splice(i,1);					return cell;				}			}			return null;		}				/**		 * Specifies the default height for all cells in this table view.		 */		public function set cellHeight(value:int):void{			_cellHeight = value;			this.needsLayout();		}		// getter for setter above.		public function get cellHeight():int{			return _cellHeight;		}			//------------------------------------		// Accessing cells.		//------------------------------------				/**		 * Returns the index for a visible cell, or -1 if the cell is not currently visible in the table view.		 */		public function indexForCell(cell:UITableViewCell):int{			if(cell == null)return -1;			return _visibleCells.indexOf(cell);		}				/**		 * Returns the cell for a certain index or null if the cell at the index is not currently visible.		 */		public function cellForIndex(index:uint):UITableViewCell{			if(index <= _visibleCells.length){				return _visibleCells[index];			}			return null;		}				/**		 * Returns all currently visible cells.		 */		public function get visibleCells():Array{			return _visibleCells.concat();		}				/**		 * Returns a messured rectangle for a specific index in the table view.		 */		public function rectForRowAt(index:int):Rectangle{			var h:int = _cellHeight;			return new Rectangle(0,index*h,width,h);		}				/**		 * Returns a Array containing all index that will be visible in the rectangle.		 */		public function rowsInRect(rect:Rectangle):Array{			var rows:Array = [];			for(var i:int = 0;i<_length;i++){				var row:Rectangle = rectForRowAt(i);				if(rect.intersects(row)){					rows.push(i);				}			}			return rows.length > 0 ? rows : null;		}						//------------------------------------		// Configuring Selection			//------------------------------------				/**		 * A <code>Boolean</code> value that determines whether the user is able to select more than one cell.		 * 		 * @default <code>false</code>		 */		public function set allowMultibleSelection(value:Boolean):void{			_allowMultibleSelection = value;		}		// getter for setter above.		public function get allowMultibleSelection():Boolean{			return _allowMultibleSelection;		}				/**		 * 		 */		public function set selectedIndex(value:int):void{			this.clearSelection();			if(value > -1 && value < _length){				_selected.unshift(value);				var cell:UITableViewCell = this.cellForIndex(value);				if(cell)					cell.selected = true;			}		}		// returns the lastest selected index.		public function get selectedIndex():int{			return _selected.length > 0 ? _selected[0] : -1;		}				/**		 * Determines of the index is flaged as selected.		 */		public function isSelected(index:int):Boolean{			return _selected.indexOf(index) != -1;		}				/**		 * 		 * 		 */		public function clearSelection():void{			while(_selected.length > 0){				var cell:UITableViewCell = cellForIndex(_selected.pop());				if(cell){					cell.selected = false;				}			}		}				/**		 * 		 * 		 */				public function scrollToSelection():void{					}				//------------------------------------		// Reloading and Updating Table View.		//------------------------------------				/**		 * 		 */		public function reload(index:int = -1,animated:Boolean = true):void{						// Reload cell at index if specified.			if(index != -1)				return reloadIndex(index,animated);						while(_visibleCells.length > 0){				var cell:UITableViewCell = _visibleCells.shift();				prepareForReuse(cell);			}			_length = _dataSource.numberOfCellsInSection(0);			_visibleCells.length = _length;			_content.height = _length*_cellHeight;	// fix bug, carculation is wrong and may start at new row.			this.needsLayout();		}				/**		 * 		 */		private function reloadIndex(index:int,animated:Boolean = false):void{			if(index < _visibleCells.length){				//trace("index where reload at "+index);			}else{				//trace("index for reload is out of range");			}		}								/**		 * 		 * 		 * @param index		 * @param length		 */		public function insertRowsAt(index:uint,length:uint):void{			if(index < _length){				var args:Array =[index,0];				while(length > 0){					args.push(null);				}				_visibleCells.splice.apply(_visibleCells,args);				_length = _visibleCells.length;				this.needsLayout();			}		}				/**		 * 		 * 		 * @param index		 * @param length		 */		public function removeRowsAt(index:uint,length:uint):void{			if(index < _length){				var cells:Array = _visibleCells.splice(index,length);				_length -= length;				while(cells.length > 0){					var cell:UITableViewCell = cells.shift();					if(cell){						if(_content.contains(cell)){							_content.removeChild(cell);						}						_reuseableCells.push(cell);					}				}				this.needsLayout();			}		}				/**		 * Pushes a cell into the reuse stack.		 */		private function prepareForReuse(cell:UITableViewCell):void{			if(!cell)return;			if(_content.contains(cell)){				_content.removeChild(cell);			}			cell.removeEventListener(MouseEvent.CLICK,onCellClick);			cell.removeEventListener(MouseEvent.DOUBLE_CLICK,onDoubleClick);			this._reuseableCells.push(cell);			cell.prepareForReuse();		}				//------------------------------------		// Updating Visual Apperance		//------------------------------------				/**		 * @inheritDoc		 */		override protected function layout(rect:Rectangle):void{			// calling super method first for correcting content bounds before laying out the view.			super.layout(rect);			// refresh the cells.			layoutView(rect);		}				/**		 * @inheritDoc		 */		override public function contentDidScroll(bounds:Rectangle):void{			layoutView(bounds);		}				/**		 * @inheritDoc		 */		protected function layoutView(bounds:Rectangle):void{			//trace("laying out sub views");			var rect:Rectangle;			var cell:UITableViewCell;			var len:int = _dataSource.numberOfCellsInSection(0);			bounds = new Rectangle(-_content.x,-_content.y,width,height);			for(var i:int = 0;i<len;i++){				rect = rectForRowAt(i);				//trace("i:",i,"bounds:",bounds,"rect:",rect);				if(bounds.intersects(rect)){					cell = _visibleCells[i] != null ? _visibleCells[i] : _dataSource.cellForRowAt(this,i);					if(cell){						cell.resize(rect.width,rect.height);						cell.selected = this.isSelected(i);						cell.render();						if(cell.parent != _content){							cell.x = rect.x;							cell.y = rect.y;							_content.addChild(cell);							cell.addEventListener(MouseEvent.CLICK,onCellClick);							cell.addEventListener(MouseEvent.DOUBLE_CLICK,onDoubleClick);						}						_visibleCells[i] = cell;					}				}else{					cell = _visibleCells[i];					if(cell){						if(cell.parent == _content){							_content.removeChild(cell);						}						cell.removeEventListener(MouseEvent.CLICK,onCellClick);						cell.removeEventListener(MouseEvent.DOUBLE_CLICK,onDoubleClick);						_reuseableCells.push(cell);					}					_visibleCells[i] = null				}			}		}				//------------------------------------		// Responding to User Interaction.		//------------------------------------				/** 		 * Handles the selection by when user clicks on a cell.		 */		private function onCellClick(e:MouseEvent):void{			var cell:UITableViewCell = e.currentTarget as UITableViewCell;			var index:int = _visibleCells.indexOf(cell);			if(_allowMultibleSelection && e.ctrlKey){				if(!isSelected(index)){					_selected.unshift(index);					cell.selected = true;				}else{					_selected.splice(_selected.indexOf(index),1);					cell.selected = false;				}			}else{				this.clearSelection();				_selected.unshift(index);				cell.selected = true;			}			this.dispatchEvent(new UITableEvent(UITableEvent.ITEM_CLICK,index));		}				/**		 * Responds to when the user double clicks on a cell.		 */		private function onDoubleClick(e:MouseEvent):void{			var cell:UITableViewCell = e.currentTarget  as UITableViewCell;			var index:int = _visibleCells.indexOf(cell);			this.dispatchEvent(new UITableEvent(UITableEvent.ITEM_DOUBLE_CLICK,index));			//trace("did double-click on cell:",cell);		}				//------------------------------------		// Deconstruction		//------------------------------------				/**		 * @inheritDoc		 */		override public function dispose():void{			// destoying the super implemenation.			super.dispose();		}		}}