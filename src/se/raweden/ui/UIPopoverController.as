package se.raweden.ui{	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.events.MouseEvent;	import flash.geom.Point;	import flash.geom.Rectangle;		import se.raweden.ui.view.UIView;	import se.raweden.ui.view.UIWindow;	/**	 * A <code>UIPopoverController</code> controller	 *	 * Copyright 2011, Raweden. All Rights Reserved.	 *	 * @author Raweden	 */	public class UIPopoverController{				// 		// TODO: Recode the logics behind the arrow direction picker, the current impl is to weak and complex.		// TODO: Fix the graphicial representation.		// TODO: Fix resizing issue.		// TODO: Fix disposing issue.		//				private var _popoverView:UIPopoverView;		private var _parent:UIView;				private var _passthrough:Array;		private var _size:Point = new Point(180,140);						private var _arrowDirection:int;		// Related Controllers.		private var _viewController:UIViewController;				/**		 * Constuctor.		 */		public function UIPopoverController(viewController:UIViewController){			_viewController = viewController;		}				/**		 * The view controller managed by this popover controller.		 */		public function set viewController(value:UIViewController):void{			_viewController = value;		}		// returns the value of the viewController attribute.		public function get viewController():UIViewController{			return _viewController;		}				/**		 * 		 */		public function set arrowDirection(value:int):void{					if(value == _arrowDirection){				return;			}						switch(value){				case ArrowDirection.DOWN:				{										break;				}				case ArrowDirection.UP:				{										break;				}				case ArrowDirection.LEFT:				{										break;				}				case ArrowDirection.RIGHT:				{										break;				}				default:				{					return;					}			}			_arrowDirection = value;		}				public function get arrowDirection():int{			return _arrowDirection;		}								//------------------------------------		// Configuring the Popover.		//------------------------------------						/**		 * 		 */		public function set contentSize(value:Point):void{			if(value){				_size.y = value.y < 140 ? 140 : value.y;				_size.x = value.x < 180 ? 180 : value.x;				}			if(_popoverView && _viewController){				_viewController.view.resize(_size.x,_size.y);				_popoverView.resize(_size.x,_size.y);			}		}		// returns the current size of the view-controller's view.		public function get contentSize():Point{			return _size.clone();		}						/**		 * An array containg views that the user can interact with without dismissing the popover.		 * 		 * <p>This provides functionally to use the content of the popover as pallet while the user is		 * interacting with other views.</p>		 * 		 * @default <code>null</code>		 */		public function set passthrough(value:Array):void{			if(value){				_passthrough = value.concat();				}else{				_passthrough = null;			}		}		// 		public function get passthrough():Array{			return _passthrough.concat();		}				//------------------------------------		// Getting informations about the Popover current State		//------------------------------------						/**		 * Indicates if the popover is currently on the display list.		 */		public function get visible():Boolean{			return _popoverView ? _popoverView.stage != null : false;		}				//------------------------------------		// Presenting and Dismissing the Popover		//------------------------------------						/**		 * 		 * @param rect The Rectangle which around the Popover will be visible.		 * @param parent The parent view where the popover will be added to.		 * @param arrowDirection The preferred arrow direction of the popover.		 * @param animated Determines if the popover should be disolved with a animation. 		 */		public function present(origin:Point,parent:UIView,arrowDirections:int,animated:Boolean = true):void{			trace("-------------- present() -------------------");			if(!_popoverView){				_popoverView = new UIPopoverView(parent,_viewController);				this.contentSize = _size;			}			_parent = parent;						_popoverView.present(parent.window,origin,arrowDirections);			_arrowDirection = arrowDirections;			trace("-------------- return; ---------------------\n");			return;						var window:UIWindow = parent.window;						// Determine the arrow direction and orgin of the view.						var origin:Point = new Point();			var direction:int = 0; // popoverOrgin(parent.window,rect,_popoverView.bounds,arrowDirections,origin);			//_popoverView.direction = direction;			// Adding the popover to the window view.			if(!window.contains(_popoverView)){				window.addChild(_popoverView);				_popoverView.x = origin.x;				_popoverView.y = origin.y;			}			_popoverView.needsDraw();			// Adding eventlisteners.			parent.addEventListener(MouseEvent.MOUSE_DOWN,onParentMouseDown);			// DEV.			trace("direction:",direction);						trace("origin",origin);			// Dev. Marks the orgin on the window.			window.graphics.clear();			window.graphics.beginFill(0xFF0000);			window.graphics.drawCircle(origin.x,origin.y,5);			window.graphics.endFill();		}				/**		 * 		 */		public function dismiss(animated:Boolean = true):void{						if(_popoverView.parent){				_popoverView.parent.removeChild(_popoverView);			}						//_popoverView.alpha = 1;			_parent.removeEventListener(MouseEvent.MOUSE_DOWN,onParentMouseDown);			_parent = null;			//Tweener.addTween(_popoverView,{alpha:0,time:0.3,onComplete:dismissComplete});		}				private function dismissComplete():void{		}				//------------------------------------		// Responding to User Interaction.		//------------------------------------				/**		 * Responds to Mouse activity inside the parent view.		 */		private function onParentMouseDown(e:MouseEvent):void{			var parent:DisplayObjectContainer = e.currentTarget as DisplayObjectContainer;			var target:DisplayObject = e.target as DisplayObject;			var exception:Boolean = false;			// Locks for a A expetion to not dismiss the Popover.			while(!exception && target != parent){				exception = target == _popoverView || _passthrough.indexOf(target) != -1;				target = target.parent;			}			// Dismisses the Popover if no exception where made.			if(!exception)				this.dismiss();		}				//------------------------------------		// Help mehtods.		//------------------------------------				/**		 * Debug method to draw areas to window.		 */		private static function drawBounds(window:UIWindow,rect:Rectangle,color:uint,alpha:Number = 0.25):void{			window.graphics.beginFill(color,alpha);			window.graphics.drawRect(rect.x,rect.y,rect.width,rect.height);			window.graphics.endFill();		}				/**		 * Determine the Origin for the popover and returns the arrow direction.		 */		private static function popoverOrgin(window:UIWindow,rect:Rectangle,size:Rectangle,directions:int,origin:Point):int{			var screen:Rectangle = window.bounds;			//window.graphics.clear();			//drawBounds(window,rect,0xFF0000);			trace("screen:",screen);						var bottomQuad:Rectangle = new Rectangle(screen.x,screen.y,screen.width,rect.y-screen.y);			var topQuad:Rectangle = new Rectangle(screen.x,screen.y+rect.y+rect.height,screen.width,screen.height-rect.y-rect.height-screen.y);			var leftQuad:Rectangle = new Rectangle(screen.x,screen.y,rect.x-screen.x,screen.height-screen.y);			var rightQuad:Rectangle = new Rectangle(rect.x+rect.width,screen.y,screen.width-rect.x-rect.width,screen.height-screen.y);						var point:Point = new Point();			point.x = rect.x+(rect.width*0.5);			point.y = rect.y+(rect.height*0.5);			var padding:Number = 40;						var allowTopOrBottom:Boolean = (point.x >= screen.left+padding && point.x <= screen.right-padding);			var allowLeftOrRight:Boolean = (point.y >= screen.top+padding && point.y <= screen.bottom-padding);						var allowTopQuad:Boolean = (directions & ArrowDirection.DOWN && topQuad.width > 0 && topQuad.height > 0 && allowTopOrBottom);			var allowBottomQuad:Boolean = (directions & ArrowDirection.UP && bottomQuad.width > 0 && bottomQuad.height > 0 && allowTopOrBottom);			var allowLeftQuad:Boolean = (directions & ArrowDirection.RIGHT && leftQuad.width > 0 && leftQuad.height > 0 && allowLeftOrRight);			var allowRightQuad:Boolean = (directions & ArrowDirection.LEFT && rightQuad.width > 0 && rightQuad.height > 0 && allowLeftOrRight);						var arrowPadding:int = 8;						origin.x = rect.x+(rect.width*0.5)-(size.x*0.5);			origin.y = rect.y+(rect.height*0.5)-(size.y*0.5);						var direction:int;						if(allowBottomQuad && SizeIsLessThanOrEqualSize(size,bottomQuad)){				point.y = rect.y;				origin.y = rect.y - size.height + arrowPadding;				direction = ArrowDirection.UP;			}else if(allowRightQuad && SizeIsLessThanOrEqualSize(size,rightQuad)){				point.x = rect.x+rect.width;				origin.x = point.x-arrowPadding;				direction = ArrowDirection.LEFT;			}else if(allowLeftQuad && SizeIsLessThanOrEqualSize(size,leftQuad)){				point.x = rect.x;				origin.x = rect.x - size.width + arrowPadding;				direction = ArrowDirection.RIGHT;			}else if(allowTopQuad && SizeIsLessThanOrEqualSize(size,topQuad)){				point.y = rect.y + rect.height;				origin.y = point.y - arrowPadding;				direction = ArrowDirection.DOWN;			}else{				throw new Error("Clould not carculate direction for arrow");			}			trace("direction set to "+direction);			trace("target rect:",rect);						trace("origin before constrians",origin);						var pop:Rectangle = new Rectangle(origin.x,origin.y,size.width,size.height);			if(pop.right > screen.right){				pop.x = screen.right - size.width-10;			}			if(pop.left < screen.left){				pop.x = screen.left+10;			}			if(pop.bottom > screen.bottom){				pop.y = screen.bottom-size.height-10;			}			if(pop.top < screen.top){				pop.y = screen.top+10;			}			//drawBounds(window,pop,0x000000,0.5);			// adjusting origin.			origin.x = pop.x;			origin.y = pop.y;			trace("origin after constrians",origin);			// returning direction.						return direction;		}				/**		 * Utility method to determine whether the popover will fit in the space around origin.		 */		private static function SizeIsLessThanOrEqualSize(a:Rectangle,b:Rectangle):Boolean{			return (a.width <= b.width) && (a.height <= b.height);		}				// destroying the popover render view.				private function dispose():void{					}			}}import flash.display.DisplayObjectContainer;import flash.display.Shape;import flash.display.Stage;import flash.events.Event;import flash.geom.Point;import flash.geom.Rectangle;import se.raweden.ui.ArrowDirection;import se.raweden.ui.UIViewController;import se.raweden.ui.view.UIView;import se.raweden.ui.view.UIWindow;class UIPopoverView extends UIView{			private var m_controller:UIViewController;	public var arrowDirection:int;	public var m_rect:Rectangle;	private var _size:Point;	public var target:Point = new Point();	private var _parent:UIView;	private var m_mask:Shape;	private var m_view:UIView;		private var m_offsetY:Number = 0;	private var m_offsetX:Number = 0.5;		public function UIPopoverView(parent:UIView,controller:UIViewController){		m_controller = controller;		_parent = parent;		// Init.		init(controller.view);	}		private function init(view:UIView):void{		// Adding Content View.		view.x = 5;		view.y = 5;		this.addChild(view);		view.mask = m_mask;		m_view = view;		// Adding Masker.		m_mask = new Shape();		this.addChild(m_mask);		view.mask = m_mask;		// Resizes to default size.		resize(view.width,view.height);	}		//------------------------------------	// Configurating the Popover	//------------------------------------		/**	 * @inheritDoc	 */	override public function resize(width:int, height:int):void{		width += 10;		height += 10;		super.resize(width,height);	}		public function set targetBounds(value:Rectangle):void{		/*		m_rect = value;		// setting the target point.		switch(arrowDirection){			case ArrowDirection.RIGHT:{				target.x = value.left+3;				target.y = value.y+(value.height*0.5);			}break;			case ArrowDirection.LEFT:{				target.x = value.right-3;				target.y = value.y+(value.height*0.5);			}break;			case ArrowDirection.DOWN:{				target.x = value.x + (value.width * 0.5);				target.y = value.top+3;			}break;			case ArrowDirection.UP:{				target.x = value.x + (value.width * 0.5);				target.y = value.bottom-3;			}break;		}		this.needsDraw();		*/	}		public function get targetBounds():Rectangle{		return m_rect;	}		//------------------------------------	// Determine the popover bounds.	//------------------------------------		public function present(parent:UIWindow,origin:Point,arrowDirections:int):void{		var screen:Rectangle = new Rectangle(0, 0, parent.width, parent.height);		var margin:Number = 20;		var arrowMargin:Number = 8;		var bounds:Rectangle = new Rectangle(0,0,width,height);		var arrowDirection:int;				trace("origin:",origin);						var topQuad:Rectangle = new Rectangle(0,0,screen.width,origin.y);		var bottomQuad:Rectangle = new Rectangle(0,origin.y,screen.width,screen.height-origin.y);		var leftQuad:Rectangle = new Rectangle(0,0,origin.x,screen.height);		var rightQuad:Rectangle = new Rectangle(origin.x,0,screen.width-origin.x,screen.height);		trace("topQuad:",topQuad);		trace("bottomQuad:",bottomQuad);		trace("leftQuad:",leftQuad);		trace("rightQuad:",rightQuad);						var allowTopOrBottom:Boolean = (origin.x >= screen.left+margin && origin.x <= screen.right-margin);		var allowLeftOrRight:Boolean = (origin.y >= screen.top+margin && origin.y <= screen.bottom-margin);		trace("allowTopOrBottom:",allowTopOrBottom);		trace("allowLeftOrRight:",allowLeftOrRight);				if( (arrowDirections & ArrowDirection.DOWN) != 0 ){			trace("- down where set");		}				if( (arrowDirections & ArrowDirection.UP) != 0 ){			trace("- up where set");		}					if( (arrowDirections & ArrowDirection.RIGHT) != 0) {			trace("- right where set");		}				if( (arrowDirections & ArrowDirection.LEFT) != 0 ){			trace("- left where set");		}				trace(ArrowDirection.DOWN.toString(16),ArrowDirection.LEFT.toString(16),ArrowDirection.RIGHT.toString(16),ArrowDirection.UP.toString(16));				trace(arrowDirections.toString(16));				var allowTopQuad:Boolean = (arrowDirections & ArrowDirection.DOWN && topQuad.width > 0 && topQuad.height > 0 && allowTopOrBottom);		var allowBottomQuad:Boolean = (arrowDirections & ArrowDirection.UP && bottomQuad.width > 0 && bottomQuad.height > 0 && allowTopOrBottom);		var allowLeftQuad:Boolean = (arrowDirections & ArrowDirection.RIGHT && leftQuad.width > 0 && leftQuad.height > 0 && allowLeftOrRight);		var allowRightQuad:Boolean = (arrowDirections & ArrowDirection.LEFT && rightQuad.width > 0 && rightQuad.height > 0 && allowLeftOrRight);		trace("allowTopQuad:",allowTopQuad);		trace("allowBottomQuad:",allowBottomQuad);		trace("allowLeftQuad:",allowLeftQuad);		trace("allowRightQuad:",allowRightQuad);				bounds.x = origin.x+-(bounds.width*0.5);		bounds.y = origin.y+-(bounds.height*0.5);				var size:Point = bounds.size;		if(allowBottomQuad &&  valid(size,bottomQuad.size) ){			bounds.y = origin.y + arrowMargin;			arrowDirection = ArrowDirection.UP;			trace("arrow direction set to up");		}else if(allowRightQuad && valid(size,rightQuad.size) ){			bounds.x = origin.x+arrowMargin;			arrowDirection = ArrowDirection.LEFT;			trace("arrow direction set to left");		}else if(allowLeftQuad && valid(size,leftQuad.size) ){			bounds.x = origin.x - (size.x + arrowMargin);			arrowDirection = ArrowDirection.RIGHT;			trace("arrow direction set to right");		}else if(allowTopQuad && valid(size,topQuad.size) ){			bounds.y = origin.y - (size.y + arrowMargin);			arrowDirection = ArrowDirection.DOWN;			trace("arrow direction set to down");					}else{			throw new Error("Clould not carculate direction for arrow");		}				if(bounds.right > screen.right){			bounds.x = screen.right - bounds.width-10;		}		if(bounds.left < screen.left){			bounds.x = screen.left+10;		}		if(bounds.bottom > screen.bottom){			bounds.y = screen.bottom-bounds.height-10;		}		if(bounds.top < screen.top){			bounds.y = screen.top+10;		}				//		this.width = bounds.width;		this.height = bounds.height;				//		this.x = bounds.x;		this.y = bounds.y;				// 		this.arrowDirection = arrowDirection;		this.needs("draw",draw);				function valid(a:Point,b:Point):Boolean{			return (a.x <= b.x) && (a.y <= b.y);		}				trace("bounds:",bounds);				parent.addChild(this);	}			public function get arrowX():int{		return 18+((_bounds.width-36)*m_offsetX);	}		public function get arrowY():int{		return 18+((_bounds.height-36)*m_offsetY);	}				//------------------------------------	// Rendering the popover.	//------------------------------------			private function updatePosition():void{		/*		trace(arrowY);		var y:int = this.y;		var x:int = this.x;		switch(arrowDirection){			case ArrowDirection.LEFT:			{				x = target.x - (this.width + 10);				y = target.y - arrowY;				break;			}			case ArrowDirection.RIGHT:			{				x = target.x + 10;				y = target.y - arrowY;				break;			}			case ArrowDirection.UP:			{				x = target.x - arrowX;				y = target.y - (this.height + 10);				break;			}			case ArrowDirection.DOWN:			{				x = target.x - arrowX;				y = target.y + 10;				break;			}		}		this.y = y;		this.x = x;		trace("this.y-target.y:",this.y-target.y);		*/	}		/**	 * @inheritDoc	 */	override protected function draw(rect:Rectangle):void{		updatePosition();		var c:int;		var x:int;		var y:int;		//		this.graphics.clear();		this.graphics.beginFill(0x2D2D2D,0.75);		this.graphics.drawRoundRect(0,0,rect.width,rect.height,12,12);		switch(arrowDirection){			case ArrowDirection.RIGHT:{				c = 18+((rect.height-36)*m_offsetY);				x = rect.width;				this.graphics.moveTo(x+10,c);				this.graphics.lineTo(x,c+10);				this.graphics.lineTo(x,c-10);			}break;			case ArrowDirection.LEFT:{				c = 18+((rect.height-36)*m_offsetY);				x = 0;				this.graphics.moveTo(x-10,c);				this.graphics.lineTo(x,c+10);				this.graphics.lineTo(x,c-10);			}break;			case ArrowDirection.UP:{				c = 18+((rect.width-36)*m_offsetX);				y = 0;				this.graphics.moveTo(c,y-10);				this.graphics.lineTo(c+10,y);				this.graphics.lineTo(c-10,y);			}break;			case ArrowDirection.DOWN:{				c = 18+((rect.width-36)*m_offsetX);				y = rect.height;				this.graphics.moveTo(c,y+10);				this.graphics.lineTo(c+10,y);				this.graphics.lineTo(c-10,y);			}break;		}		this.graphics.endFill();		// Draws the masker.		m_mask.graphics.clear();		m_mask.graphics.beginFill(0x000000);		m_mask.graphics.drawRoundRect(5,5,rect.width-10,rect.height-10,8,8);		m_mask.graphics.endFill();	}	}