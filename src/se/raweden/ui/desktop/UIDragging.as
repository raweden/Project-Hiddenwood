package se.raweden.ui.desktop{	import flash.display.InteractiveObject;	import flash.events.MouseEvent;	import flash.geom.Point;	/**	 * A <code>UIDragging</code> represents a dragging session.	 * 	 * @copyright Copyright 2011 Raweden. All rights reserved.	 * @author Raweden	 */	public class UIDragging{				private static var m_currentSequence:int = 0;				private var m_pasteboard:UIPasteboard;		private var m_event:MouseEvent;		private var m_items:Array;		private var m_offset:Point;		private var m_sequence:int = -1;		private var m_location:Point;		// public vars.		public var slideBack:Boolean = false;				private var m_formation:String = UIDraggingFormation.NONE;		private var m_images:Array;				/**		 * 		 */		public function UIDragging(pasteboard:UIPasteboard,images:Array,operation:int = UIDraggingOperation.NONE){			m_pasteboard = pasteboard;			m_images = images;		}				//------------------------------------		// Dragging Pasteboard.		//------------------------------------				/**		 * A <code>UIPasteboard</code> provided with this dragging session.		 */		public final function get pasteboard():UIPasteboard{			return m_pasteboard;		}				/**		 * A integer representing the operations that can be applied to <code>UIPasteboard</code>.		 * 		 * @see UIDraggingOperation		 */		public final function get operation():int{			return int.MAX_VALUE;		}				//------------------------------------		// Managing Dragging Images		//------------------------------------				/**		 * 		 */		public final function get images():Array{			return m_images;		}				/**		 * Determines the formation that dragging images are arranged in.		 * 		 * @see UIDraggingFormation		 */		public final function get formation():String{			return m_formation;		}						//------------------------------------		// Identifying the Dragging Session.		//------------------------------------				/**		 * A sequence number that is uniqe for this dragging session.		 * 		 * @default <code>-1</code>		 */		public final function get sequence():uint{			return m_sequence;		}				//------------------------------------		// Dragging Session Localtion Attributes.		//------------------------------------		/**		 * The current dragging trackpoint location in stage coordinates.		 */		public final function get location():Point{			return UIDraggingPrivate.session == this ? UIDraggingPrivate.location.clone() : null;		}				/**		 * 		 */		public final function set draggingOffset(value:Point):void{			m_offset = value;		}		// returns the dragging offset.		public final function get draggingOffset():Point{			return m_offset;		}						//------------------------------------		// Dragging Session Localtion Attributes.		//------------------------------------						/**		 * DOCS.!		 */		public static function beginDragging(session:UIDragging,source:InteractiveObject,images:Array,event:MouseEvent):void{				UIDraggingPrivate.beginDragging(session,source,images,event);					session.m_event = event;				// specifying the sequence id.				session.m_sequence = m_currentSequence;				m_currentSequence++;		}				/**		 * 		 */		public final function enumerateDraggingImages(view:InteractiveObject,callback:Function):void{					}				/**		 * A Boolean value that determine whether the user is currently dragging a session.		 */		public static function get isDragging():Boolean{			return UIDraggingPrivate.session != null;		}				/**		 * 		 */		public final function slideTo(x:Number,y:Number):void{					}					}}import caurina.transitions.Tweener;import flash.display.Bitmap;import flash.display.InteractiveObject;import flash.display.Stage;import flash.events.Event;import flash.events.MouseEvent;import flash.geom.Point;import se.raweden.ui.desktop.IDraggingDestination;import se.raweden.ui.desktop.UIDragging;import se.raweden.ui.events.UIDragEvent;/** * This class is a private implementation of the dragging behavior in Core UI. */class UIDraggingPrivate{		//	// TODO: clean up after a dragging session is Completed.	// TODO: allow alternative dragging image update.	// TODO: allow images to be animated to destination cordinates as the images are alternativly updated.	// TODO: fix begin dragging bug, the image is offset from the last offset used.	// TODO: add support for sliding dragging images to specific location when dropped (m_destinationLocation).	//		// current session 	private static var m_session:UIDragging;	private static var m_slideBack:Boolean;	// current location and velocity.	private static var m_location:Point = new Point();	private static var vx:int;	private static var vy:int;	// dragging images.	private static var m_image:Bitmap = new Bitmap();	// destination and source.	private static var m_source:InteractiveObject;	private static var m_sourceLocation:Point;	private static var m_destination:IDraggingDestination;	// global reference.	private static var m_stage:Stage;			private static var m_mouse:Point;	// temporary saved locations.			public static function beginDragging(session:UIDragging,source:InteractiveObject,images:Array,event:MouseEvent):void{		m_session = session;		if(!m_stage)			m_stage =  InteractiveObject(event.currentTarget).stage;		// adding eventlistners to the stage.		m_stage.addEventListener(Event.ENTER_FRAME,onEnterFrame);		m_stage.addEventListener(MouseEvent.MOUSE_MOVE,onDragUpdate);		m_stage.addEventListener(MouseEvent.MOUSE_UP,onDragEnd);		m_stage.addEventListener(MouseEvent.MOUSE_OVER,onDragEnter);		m_stage.addEventListener(MouseEvent.MOUSE_OUT,onDragExit);		m_stage.addEventListener(Event.MOUSE_LEAVE,onMouseLeave);		// setting start location.		m_sourceLocation = new Point(m_stage.mouseX,m_stage.mouseY);		m_mouse = new Point(m_stage.mouseX,m_stage.mouseY);		// temporay setting up image.		if(images && images.length > 0 && images[0].hasOwnProperty("image")){			m_image.bitmapData = images[0].image;			m_stage.addChild(m_image);			if(m_session.draggingOffset){				m_image.x = m_stage.mouseX-m_session.draggingOffset.x;				m_image.y = m_stage.mouseY-m_session.draggingOffset.y;				}else{				m_image.x = m_stage.mouseX;				m_image.y = m_stage.mouseY;			}		}		m_source = source;	}		//------------------------------------	// Responding to User Interaction.	//------------------------------------		// triggerd on each frame as the dragging is active.	private static function onEnterFrame(e:Event):void{		// getting current mouse position.		var x:int = m_stage.mouseX;		var y:int = m_stage.mouseY;		// carculating the the velocity in pixel/frame		vx = x-m_mouse.x;		vy = y-m_mouse.y;		// updating the last known mouse postion.		m_mouse.x = x;		m_mouse.y = y;				// TODO: Carculate the velocity of the user interaction.		// TODO: Determine if the current destionation is a posible drop destination by the current velocity.			}		// triggerd when the user moves the mouse as the dragging is active.	private static function onDragUpdate(e:Event):void{		var x:int = m_stage.mouseX;		var y:int = m_stage.mouseY;		// setting the positon of the image.		if(m_session.draggingOffset){			m_image.x = x-m_session.draggingOffset.x;			m_image.y = y-m_session.draggingOffset.y;			}else{			m_image.x = x;			m_image.y = y;		}				// TODO: Use mouse.move Here instead of EnterFrame		// TODO: Update location of the dragging images.				// setting the location.		m_location.x = x;		m_location.y = y;	}		// triggerd when the dragging is entering the bounds of an InteractiveObject.	private static function onDragEnter(e:MouseEvent):void{		var target:IDraggingDestination = e.target is InteractiveObject ? e.target as IDraggingDestination : null;		if(target){			var accepted:Boolean = target.acceptsDrop(m_session);			if(target && accepted)				m_destination = target;			}		trace("dragging did enter:",target,"accepted:",accepted);	}		// triggerd when the dragging is exiting the bounds of an Interactive Object.	private static function onDragExit(e:MouseEvent):void{		var target:IDraggingDestination = e.target is InteractiveObject ? e.target as IDraggingDestination : null;		if(target == m_destination){			m_destination = null;		}		trace("dragging did exit:",target);	}			// triggerd when the dragging is relased.	private static function onDragEnd(e:MouseEvent):void{		// removing eventlistners.		m_stage.removeEventListener(Event.ENTER_FRAME,onEnterFrame);		m_stage.removeEventListener(MouseEvent.MOUSE_MOVE,onDragUpdate);		m_stage.removeEventListener(MouseEvent.MOUSE_UP,onDragEnd);		m_stage.removeEventListener(MouseEvent.MOUSE_OVER,onDragEnter);		m_stage.removeEventListener(MouseEvent.MOUSE_OUT,onDragExit);		m_stage.addEventListener(Event.MOUSE_LEAVE,onMouseLeave);		// validates if the pasteboard can be dropped in the current location.		var local:Array = m_stage.getObjectsUnderPoint(m_location);		var destination:IDraggingDestination;		var valid:Boolean = false;		for(var i:int = 0;i<local.length;i++){			var target:InteractiveObject = local[i] as InteractiveObject;			if(target is IDraggingDestination && IDraggingDestination(target).acceptsDrop(m_session)){				destination = target as IDraggingDestination;				break;			}		}		// if a destination where found.		if(destination){			destination.dispatchEvent(new UIDragEvent(UIDragEvent.DROP,m_session,m_location.clone()));			completeDragEnd();		}else if(m_session.slideBack){			var x:Number = m_sourceLocation.x-m_session.draggingOffset.x;			var y:Number = m_sourceLocation.y-m_session.draggingOffset.y;			Tweener.addTween(m_image,{time:0.4,x:x,y:y,onComplete:completeDragEnd});			}else{			completeDragEnd();		}		// cleaning up from dragging session.		m_destination = null;		m_source = null;		log("dragging did end - destination:",destination);	// remove this!	}		// triggerd when the slideback is complete or when the dragging is relased.	private static function completeDragEnd():void{		if(m_stage.contains(m_image)){			m_stage.removeChild(m_image);		}	}		// triggerd when the mouse leaves the stage area.	private static function onMouseLeave(e:Event):void{		if(m_session){			if(m_session.slideBack){				var x:Number = m_sourceLocation.x-m_session.draggingOffset.x;				var y:Number = m_sourceLocation.y-m_session.draggingOffset.y;				Tweener.addTween(m_image,{time:0.4,x:x,y:y,onComplete:completeDragEnd});			}else{				completeDragEnd();			}		}	}		//------------------------------------	// Delays the update of the dragging items.	//------------------------------------	// 	// TODO: Determine if the current 'hover' target is a posible destionation by velocity and delay	// TODO: Allow the IDraggingDestination to update the dragging images.	// TODO: mark IDraggingDestion as updated so no updates twice.	//		//------------------------------------	// Getting Attributes.	//------------------------------------	/**	 * Returns the current UIDragging session.	 */	public static function get session():UIDragging{		return m_session;	}		/**	 * Returns the <code>InteractiveObject</code> that initilized the current dragging session.	 */	public static function get source():InteractiveObject{		return m_source;	}		/**	 * Returns the current dragging location in the <code>Stage</code> cordinate space.	 */	public static function get location():Point{		return m_location;	}	}